# 动画系统完整文档

**版本**: v1.0  
**日期**: 2025-12-16  
**状态**: ✅ 已完成  
**合并来源**: 人物与工具动画同步方案总结.md、动画同步离散帧边界问题解决方案.md、手持工具同步功能.md、疾跑状态管理系统.md

---

## 第一部分：当前架构

```
Player
└── Tool    ← 单一工具子对象，动态切换 Controller
```

早期规划的复杂分组架构（SliceGroup/CrushGroup/PierceGroup）已废弃。

---

## 第二部分：核心同步机制 - Mode A++（帧索引硬锁）

### 问题背景
- 工具与人物动画存在1-2帧延迟
- 大位移帧出现明显拖影
- 连续时间对齐在离散边界上产生误差

### 失败尝试
1. **Mode A**：纯参数镜像 + 时间对齐 → 边界处仍有1帧拖影
2. **Mode A+**：参数镜像 + 当帧评估 → 问题依旧
3. **单Animator合成剪辑** → 改造量大，侵入性高

### 最终方案：帧索引硬锁

用"帧号"而非"时间"做同步基准：

```csharp
// LayerAnimSync.cs 核心逻辑
void LateUpdate()
{
    // 1. 镜像状态参数
    toolAnimator.SetInteger("State", playerAnimator.GetInteger("State"));
    toolAnimator.SetInteger("Direction", playerAnimator.GetInteger("Direction"));
    toolAnimator.Update(0);  // 当帧评估

    // 2. 从Player Sprite名称解析帧号
    int playerFrame = ParseFrameFromSpriteName(playerSprite.sprite.name);
    
    // 3. 按帧数比例映射到Tool帧号
    int mappedToolIndex = Mathf.RoundToInt(playerFrame * (toolCount - 1f) / (playerCount - 1f));
    
    // 4. 计算normalizedTime（带极小偏置避免边界抖动）
    float toolNorm = (mappedToolIndex / (float)(toolCount - 1)) + 1e-6f;
    
    // 5. 强制同步
    toolAnimator.Play(targetHash, 0, toolNorm);
    toolAnimator.Update(0);
    
    // 6. 同步显隐和排序
    toolRenderer.sortingOrder = playerRenderer.sortingOrder - 1;
    toolRenderer.flipX = playerRenderer.flipX;
}
```

### 效果
- ✅ 完全消除拖影
- ✅ 零帧延迟同步
- ✅ 支持多方向、多品质、多工具类型

---

## 第三部分：工具动作锁定系统

### 三个核心突破

| 问题 | 解决方案 |
|------|----------|
| 长按期间鬼畜 | 时间计时器替代 normalizedTime |
| 方向切换抽搐 | ForcePlayAnimation 智能方向检测 |
| 动画结束闪烁 | ForceHideTool / AllowToolShow 机制 |

### 时间计时器（替代不稳定的 normalizedTime）

```csharp
// PlayerAnimController.cs
private float toolAnimationDuration = 0.8f;
private float _actionStartTime = 0f;

public void StartAnimationTracking()
{
    _actionStartTime = Time.time;
    _isPerformingToolAction = true;
}

public bool IsAnimationFinished()
{
    if (!_isPerformingToolAction) return true;
    return Time.time - _actionStartTime >= toolAnimationDuration;
}
```

### 智能方向检测（方向不变时不重置动画）

```csharp
public void ForcePlayAnimation(AnimState state, AnimDirection direction, bool shouldFlip)
{
    bool directionChanged = (direction != currentDirection) || (shouldFlip != isFlipped);
    
    if (directionChanged)
    {
        PlayAnimationInternal(state, direction, shouldFlip);
    }
    // 方向不变：让动画自然循环
}
```

### 强制隐藏机制（防止结束闪烁）

```csharp
// LayerAnimSync.cs
private bool _forceHideUntilNextAction = false;

public void ForceHideTool()
{
    _forceHideUntilNextAction = true;
    toolSpriteRenderer.enabled = false;
}

public void AllowToolShow()
{
    _forceHideUntilNextAction = false;
}
```

---

## 第四部分：动画状态映射

### AnimState 枚举

```csharp
public enum AnimState
{
    Idle = 0,       // 待机站立
    Walk = 1,       // 行走
    Run = 2,        // 跑步
    Carry = 3,      // 举着物体
    Collect = 4,    // 捡起物体
    Hit = 5,        // 受击
    Slice = 6,      // 挥砍（斧头/镰刀）
    Pierce = 7,     // 刺出（长剑）
    Crush = 8,      // 挖掘（镐子/锄头）
    Fish = 9,       // 钓鱼
    Watering = 10,  // 浇水
    Death = 11      // 死亡
}
```

### 工具类型到动画状态映射

| 工具 | AnimState | 值 |
|------|-----------|-----|
| 斧头/镰刀 | Slice | 6 |
| 镐子/锄头 | Crush | 8 |
| 长剑 | Pierce | 7 |
| 鱼竿 | Fish | 9 |
| 洒水壶 | Watering | 10 |

> ⚠️ **注意**：锄头使用 Crush (8)，与镐子共用挖掘动画！

---

## 第五部分：命名规范

### 动画资产命名
- 状态/剪辑名：`{ActionType}_{Direction}_Clip_{itemId}_{quality}`
- 控制器：`{ActionType}_Controller_{itemId}_{itemName}.controller`

### 文件结构
```
Assets/Animations/
├── Clips/{ActionType}/{id}_{itemName}/{Down|Side|Up}/
│   └── {Action}_{Dir}_Clip_{id}_{quality}.anim
└── Controllers/{ActionType}/{id}_{itemName}/
    └── {Action}_Controller_{id}_{itemName}.controller
```

### Animator 参数
- `State(int)`：动画状态
- `Direction(int)`：方向（0=Down, 1=Side, 2=Up）
- `ToolItemId(int)`：工具物品ID
- `ToolQuality(int)`：工具品质
- `FlipX(bool)`：水平翻转

---

## 第六部分：疾跑状态管理系统

### 功能概述
- 3秒疾跑记忆：3秒内有过疾跑，新导航默认疾跑
- 双击切换模式：双击右键切换疾跑/行走
- 长按疾跑模式：长按右键疾跑，松开停止
- 体力系统预留接口

### 核心设计

```csharp
// SprintStateManager.cs
public class SprintStateManager : MonoBehaviour
{
    public static SprintStateManager Instance { get; private set; }
    
    [SerializeField] private float sprintMemoryDuration = 3f;
    private float lastSprintTime = -999f;
    
    public bool HasRecentSprint()
    {
        return Time.time - lastSprintTime < sprintMemoryDuration;
    }
    
    public void RecordSprint()
    {
        lastSprintTime = Time.time;
    }
}
```

### 导航模式
- **Toggle**：双击切换，适合探索
- **HoldToSprint**：长按疾跑，适合战斗

---

## 第七部分：数据流

```
用户输入（鼠标左键）
    │
    ▼
PlayerInteraction.PerformAction()
    ├── ToolActionLockManager.BeginAction()
    ├── LayerAnimSync.AllowToolShow()  ← 允许显示
    └── PlayerAnimController.PlayAnimation()
                │
                ▼
          动画播放中...
          （LayerAnimSync 帧同步）
          （时间计时器计时）
                │
                ▼
PlayerAnimController.IsAnimationFinished()  ← 基于时间计时器
    │
    ▼
PlayerInteraction.OnActionComplete()
    ├── ApplyCachedDirectionToFacing()  ← 先应用缓存方向
    │
    ├── [继续长按] → ForcePlayAnimation()
    │
    └── [松开] → LayerAnimSync.ForceHideTool()  ← 强制隐藏
```

---

## 第八部分：配置要点

| 参数 | 位置 | 说明 |
|------|------|------|
| toolAnimationDuration | PlayerAnimController | ★ 必须与动画剪辑时长匹配（默认0.8秒） |
| lastFrameLockThreshold | LayerAnimSync | 最后一帧锁定阈值（默认0.85） |
| enableLastFrameLock | LayerAnimSync | 启用最后一帧锁定 |
| sprintMemoryDuration | SprintStateManager | 疾跑记忆时间（默认3秒） |

---

## 第九部分：经验教训

1. **不要依赖 normalizedTime** - 用简单时间计时器更可靠
2. **方向不变时不重置动画** - 避免抽搐
3. **主动控制工具显隐** - 避免闪烁
4. **缓存在动画结束时应用** - 避免延迟感
5. **架构从简** - 早期复杂分组架构已废弃

---

## 第十部分：相关文件

| 文件 | 职责 |
|------|------|
| `Assets/Scripts/Service/Player/PlayerInteraction.cs` | 动作触发、完成检测 |
| `Assets/Scripts/Anim/Player/PlayerAnimController.cs` | 动画播放、时间计时器 |
| `Assets/Scripts/Anim/_...._/LayerAnimSync.cs` | 帧同步、显隐控制 |
| `Assets/Scripts/Service/Player/ToolActionLockManager.cs` | 输入锁定、缓存 |
| `Assets/Scripts/Anim/Player/PlayerToolController.cs` | 工具切换、参数设置 |
| `Assets/Scripts/Service/Player/SprintStateManager.cs` | 疾跑状态管理 |

---

*文档结束 - 本文档合并了人物与工具动画文件夹的所有内容*
