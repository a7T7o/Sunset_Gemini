# é®æŒ¡ä¸å¯¼èˆªç³»ç»Ÿå®Œæ•´æ–‡æ¡£

**ç‰ˆæœ¬**: v1.0  
**æ—¥æœŸ**: 2025-12-16  
**çŠ¶æ€**: âœ… å·²å®Œæˆ  
**åˆå¹¶æ¥æº**: å¯¼èˆªæ¨¡å—å®Œæ•´æ–¹æ¡ˆ.mdã€é®æŒ¡é€æ˜ç³»ç»Ÿv2.0-æœ€ç»ˆæ€»ç»“.md åŠå…¶ä»–é®æŒ¡å¯¼èˆªç›¸å…³æ–‡æ¡£

---

# ç¬¬ä¸€éƒ¨åˆ†ï¼šå¯¼èˆªç³»ç»Ÿ

## 1.1 ç³»ç»Ÿæ¦‚è¿°

ä¸º 2D å†œåœºæ¨¡æ‹Ÿæ¸¸æˆæä¾›å®Œæ•´çš„å¯¼èˆªè§£å†³æ–¹æ¡ˆï¼š
- å³é”®ç‚¹å‡»è‡ªåŠ¨å¯»è·¯
- A* å¯»è·¯ç®—æ³•ï¼ˆå…«æ–¹å‘ã€ä¸¥æ ¼å¯¹è§’çº¿æ£€æµ‹ï¼‰
- åŠ¨æ€éšœç¢ç‰©é¿è®©
- ä¸–ç•Œè¾¹ç•Œè‡ªåŠ¨æ£€æµ‹

### æ ¸å¿ƒç»„ä»¶

| ç»„ä»¶ | èŒè´£ |
|------|------|
| `NavGrid2D` | ç½‘æ ¼æ„å»ºã€A* å¯»è·¯ç®—æ³•ã€éšœç¢ç‰©æ£€æµ‹ |
| `PlayerAutoNavigator` | è·¯å¾„æ‰§è¡Œã€è§†çº¿ä¼˜åŒ–ã€ç¢°æ’é¢„è­¦ |

## 1.2 NavGrid2D é…ç½®

```csharp
[Header("ç½‘æ ¼è®¾ç½®")]
[SerializeField] private float cellSize = 0.5f;           // ç½‘æ ¼å¤§å°
[SerializeField] private float probeRadius = 0.5f;        // éšœç¢ç‰©æ¢æµ‹åŠå¾„
[SerializeField] private bool eightDirections = true;     // 8æ–¹å‘ç§»åŠ¨
[SerializeField] private bool strictCornerCutting = true; // ä¸¥æ ¼å¯¹è§’çº¿æ£€æµ‹

[Header("ä¸–ç•Œè¾¹ç•Œè®¾ç½®")]
[SerializeField] private bool autoDetectWorldBounds = true;
[SerializeField] private string[] worldLayerNames = { "LAYER 1", "LAYER 2", "LAYER 3" };
[SerializeField] private float boundsPadding = 5f;

[Header("éšœç¢ç‰©æ ‡ç­¾")]
[SerializeField] private string[] obstacleTags = { "Tree", "Building", "Rock" };
```

## 1.3 ä¸–ç•Œè¾¹ç•Œè‡ªåŠ¨æ£€æµ‹

```csharp
private void DetectWorldBounds()
{
    Bounds totalBounds = new Bounds();
    
    // 1. æ‰«ææ‰€æœ‰ Tilemap
    var tilemaps = FindObjectsByType<Tilemap>(FindObjectsSortMode.None);
    foreach (var tilemap in tilemaps)
    {
        if (!IsInWorldLayers(tilemap.transform)) continue;
        totalBounds.Encapsulate(tilemap.localBounds);
    }

    // 2. æ‰«ææ‰€æœ‰ Collider2Dï¼ˆè¡¥å……ï¼‰
    var colliders = FindObjectsByType<Collider2D>(FindObjectsSortMode.None);
    foreach (var col in colliders)
    {
        if (!IsInWorldLayers(col.transform)) continue;
        if (col.CompareTag("Player")) continue;
        totalBounds.Encapsulate(col.bounds);
    }

    // 3. æ‰©å±•è¾¹ç•Œå¹¶åº”ç”¨
    totalBounds.Expand(boundsPadding * 2f);
    worldOrigin = totalBounds.min;
    worldSize = totalBounds.size;
}
```

## 1.4 ä¸¥æ ¼å¯¹è§’çº¿æ£€æµ‹

```csharp
private bool TryMakeDiagonal(int x, int y, int dx, int dy, out Vector2Int result)
{
    int nx = x + dx, ny = y + dy;
    
    // ä¸¤æ¡ç›¸é‚»è¾¹å¿…é¡»å¯èµ°
    if (!IsWalkable(x + dx, y) || !IsWalkable(x, y + dy))
    {
        result = default;
        return false;
    }
    
    // å¯¹è§’æ ¼æœ¬èº«å¿…é¡»å¯èµ°
    if (!IsWalkable(nx, ny)) { result = default; return false; }
    
    // ä¸¥æ ¼æ¨¡å¼ï¼šæ£€æŸ¥å¯¹è§’çº¿ä¸­ç‚¹
    if (strictCornerCutting)
    {
        Vector2 mid = (GridToWorldCenter(x, y) + GridToWorldCenter(nx, ny)) * 0.5f;
        if (IsPointBlocked(mid, probeRadius * 0.5f))
        {
            result = default;
            return false;
        }
    }
    
    result = new Vector2Int(nx, ny);
    return true;
}
```

## 1.5 å…¨å±€åˆ·æ–°äº‹ä»¶

```csharp
// NavGrid2D.cs
public static System.Action OnRequestGridRefresh;

// ä½¿ç”¨æ–¹å¼ï¼ˆå¦‚ TreeControllerï¼‰
NavGrid2D.OnRequestGridRefresh?.Invoke();
```

## 1.6 PlayerAutoNavigator é…ç½®

```csharp
[Header("åœæ­¢/å®¹å·®")]
[SerializeField] private float stopDistance = 0.2f;
[SerializeField] private float waypointTolerance = 0.1f;

[Header("æ™ºèƒ½è·¯å¾„æ›´æ–°")]
[SerializeField] private float destinationChangeThreshold = 0.3f;  // ç›®æ ‡ç‚¹å»æŠ–
[SerializeField] private bool enablePathMerging = true;

[Header("è§†çº¿ä¼˜åŒ–")]
[SerializeField] private bool enableLineOfSightOptimization = true;
[SerializeField] private float safetyMargin = 0.2f;
```

## 1.7 æ€§èƒ½å‚è€ƒ

| åœºæ™¯å¤§å° | æ ¼å­æ•°é‡ | é‡å»ºæ—¶é—´ |
|---------|---------|---------|
| 50Ã—50 | 10,000 | ~50ms |
| 100Ã—80 | 32,000 | ~150ms |
| 200Ã—200 | 160,000 | ~800ms |

**æ¨è**ï¼š100Ã—80 åœºæ™¯ï¼ŒcellSize=0.5

---

# ç¬¬äºŒéƒ¨åˆ†ï¼šé®æŒ¡é€æ˜ç³»ç»Ÿ

## 2.1 ç³»ç»Ÿæ¦‚è¿°

å½“ç©å®¶èµ°åˆ°æ ‘æœ¨ã€å»ºç­‘ç­‰ç‰©ä½“ä¸‹æ–¹æ—¶ï¼Œè¿™äº›ç‰©ä½“ä¼šè‡ªåŠ¨å˜é€æ˜ã€‚

**æ ¸å¿ƒé€»è¾‘**ï¼š
```
ç©å®¶åœ¨ç‰©ä½“ä¸‹æ–¹ï¼ˆYåæ ‡æ›´å¤§ï¼‰+ Spriteè§†è§‰é‡å  â†’ ç‰©ä½“é€æ˜
```

## 2.2 æ ¸å¿ƒç‰¹æ€§

- **Bounds.Intersectsæ£€æµ‹**ï¼šæ€§èƒ½æ˜¯OverlapPointçš„20å€
- **åŒå±‚ç»“æ„æ”¯æŒ**ï¼šå®Œç¾é€‚é…TreeControllerçš„çˆ¶å­ç‰©ä½“ç»“æ„
- **æ™ºèƒ½è¿‡æ»¤**ï¼šYåæ ‡é¢„æ£€æµ‹ã€è·ç¦»è¿‡æ»¤ã€æ ‡ç­¾è¿‡æ»¤
- **å¹³æ»‘è¿‡æ¸¡**ï¼šé€æ˜åº¦å¹³æ»‘æ’å€¼

## 2.3 æ£€æµ‹æµç¨‹

```csharp
void DetectOcclusion()
{
    // 1. ç§»åŠ¨æ£€æµ‹ï¼ˆä¼˜åŒ–ï¼‰
    if (ç©å®¶ç§»åŠ¨è·ç¦» < 0.1) return;
    
    // 2. éå†æ‰€æœ‰æ³¨å†Œç‰©ä½“
    foreach (ç‰©ä½“ in æ³¨å†Œåˆ—è¡¨)
    {
        // 3. Yåæ ‡é¢„æ£€æµ‹
        if (ç©å®¶Y <= ç‰©ä½“Y) continue;
        
        // 4. è·ç¦»è¿‡æ»¤
        if (è·ç¦» > æ£€æµ‹åŠå¾„) continue;
        
        // 5. æ ‡ç­¾è¿‡æ»¤
        if (æ ‡ç­¾ä¸åŒ¹é…) continue;
        
        // 6. Boundsæ£€æµ‹
        if (ç©å®¶Bounds.Intersects(ç‰©ä½“Bounds))
        {
            ç‰©ä½“.SetOccluding(true);
        }
    }
}
```

## 2.4 OcclusionManager é…ç½®

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| detectionRadius | 8 | æ£€æµ‹åŠå¾„ |
| detectionInterval | 0.1 | æ£€æµ‹é—´éš”ï¼ˆç§’ï¼‰ |
| occludableTags | Trees, Rocks, Buildings | å¯é®æŒ¡æ ‡ç­¾ |

## 2.5 OcclusionTransparency é…ç½®

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| occludedAlpha | 0.3 | é®æŒ¡æ—¶é€æ˜åº¦ |
| fadeSpeed | 8 | è¿‡æ¸¡é€Ÿåº¦ |
| affectChildren | true | å½±å“æ‰€æœ‰å­ç‰©ä½“ |

## 2.6 æ ‘æ—è¿é€šæ€§åˆ¤å®š

```csharp
private bool AreTreesConnected(OcclusionTransparency a, OcclusionTransparency b)
{
    // æ¡ä»¶1ï¼šæ ‘æ ¹è·ç¦» <= 2.5m
    float rootDistance = Vector2.Distance(rootA, rootB);
    if (rootDistance <= rootConnectionDistance) return true;
    
    // æ¡ä»¶2ï¼šæ ‘å† é‡å  >= 15%
    float overlapRatio = CalculateOverlapRatio(boundsA, boundsB);
    return overlapRatio >= 0.15f;
}
```

---

# ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¸¸è§é—®é¢˜æ’æŸ¥

## å¯¼èˆªé—®é¢˜

### é—®é¢˜1ï¼šå¯¼èˆªæ— å“åº”
- æ£€æŸ¥ä¸–ç•Œè¾¹ç•Œæ˜¯å¦è¦†ç›–ç‚¹å‡»ä½ç½®
- æ£€æŸ¥èµ·ç‚¹/ç»ˆç‚¹æ˜¯å¦åœ¨éšœç¢ç‰©å†…
- å¯ç”¨ `logObstacleDetection` æŸ¥çœ‹è¾¹ç•Œ

### é—®é¢˜2ï¼šè·¯å¾„ç©¿å¢™
- ç¡®ä¿ `losObstacleMask` ä¸ NavGrid2D çš„ `obstacleMask` ç›¸åŒ
- ç¡®ä¿ `losObstacleTags` åŒ…å«æ‰€æœ‰éšœç¢ç‰©æ ‡ç­¾
- å¯ç”¨ `strictCornerCutting`

### é—®é¢˜3ï¼šé¢‘ç¹ç‚¹å‡»é¬¼ç•œ
- å¯ç”¨ `enablePathMerging`
- å¢å¤§ `destinationChangeThreshold`ï¼ˆ0.3~0.5ï¼‰

## é®æŒ¡é—®é¢˜

### é—®é¢˜1ï¼šæ ‘ä¸é€æ˜
- æ£€æŸ¥åœºæ™¯æ˜¯å¦æœ‰OcclusionManager
- æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åŒ¹é…ï¼ˆTreesï¼‰
- æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨æ£€æµ‹èŒƒå›´å†…

### é—®é¢˜2ï¼šOrderè®¡ç®—é”™è¯¯
- æ‰§è¡Œ Tools â†’ ğŸ”§ æ ¡å‡†æ‰€æœ‰é™æ€ç‰©ä½“Order

---

# ç¬¬å››éƒ¨åˆ†ï¼šç›¸å…³æ–‡ä»¶

| æ–‡ä»¶ | èŒè´£ |
|------|------|
| `Assets/Scripts/Service/Navigation/NavGrid2D.cs` | å¯¼èˆªç½‘æ ¼ |
| `Assets/Scripts/Service/Player/PlayerAutoNavigator.cs` | ç©å®¶è‡ªåŠ¨å¯¼èˆª |
| `Assets/Scripts/Service/Rendering/OcclusionManager.cs` | é®æŒ¡ç®¡ç†å™¨ |
| `Assets/Scripts/Service/Rendering/OcclusionTransparency.cs` | é®æŒ¡é€æ˜ç»„ä»¶ |
| `Assets/Editor/BatchAddOcclusionComponents.cs` | æ‰¹é‡æ·»åŠ å·¥å…· |
| `Assets/Editor/StaticObjectOrderAutoCalibrator.cs` | Orderæ ¡å‡†å·¥å…· |

---

*æ–‡æ¡£ç»“æŸ - æœ¬æ–‡æ¡£åˆå¹¶äº†é®æŒ¡ä¸å¯¼èˆªæ–‡ä»¶å¤¹çš„æ‰€æœ‰å†…å®¹*
