# 混合导航系统使用指南

**版本**: v4.0  
**日期**: 2024-12-04  
**作者**: Cascade AI  

---

## 📋 目录

1. [概述](#概述)
2. [核心特性](#核心特性)
3. [配置说明](#配置说明)
4. [使用方法](#使用方法)
5. [NPC/怪物扩展](#npc怪物扩展)
6. [技术细节](#技术细节)
7. [故障排查](#故障排查)

---

## 概述

混合导航系统结合了**网格寻路（快速高效）**和**连续空间导航（精确灵活）**，可以：

- ✅ **保留所有现有功能**：路径合并、视线优化、速度自适应等
- ✅ **处理极限场景**：狭窄通道、复杂障碍物交叠
- ✅ **为NPC/怪物预留接口**：统一的导航能力
- ✅ **完全向后兼容**：默认关闭，不影响现有项目

### 导航模式对比

| 场景类型 | 导航模式 | 说明 |
|---------|---------|------|
| 开阔区域 | Grid模式 | 使用NavGrid2D，快速高效 |
| 极限狭窄通道 | Continuous模式 | 使用势场法，精确避障 |
| 复杂障碍物密集区 | Continuous模式 | 自动切换，动态避障 |

---

## 核心特性

### 1. 自动模式切换

系统会根据玩家周围的障碍物密度自动切换导航模式：

```csharp
// 判定规则：周围障碍物数量 >= complexAreaThreshold
if (周围障碍物 >= 3)
    → 切换到Continuous模式（连续空间导航）
else
    → 使用Grid模式（网格寻路）
```

### 2. 势场法导航

**Continuous模式**使用势场法计算移动方向：

- **目标吸引力**：指向目标点
- **障碍物排斥力**：远离周围障碍物
- **最终方向** = 吸引力 + 排斥力 × 强度系数

### 3. 动态路径探索

如果计算的方向被阻挡，系统会自动尝试多个角度：

```
期望方向 → 被堵
  ↓
尝试 ±15°, ±30°, ±45°, ±60°, ±75°
  ↓
找到第一个可通过的方向
```

### 4. CircleCast连续碰撞检测

使用`Physics2D.CircleCast`进行像素级精确检测：

- **输入**：起点、玩家半径、方向、距离
- **输出**：路径是否被阻挡
- **优势**：可以检测红色格子内的空隙

---

## 配置说明

### PlayerAutoNavigator配置

在Unity Inspector中找到**"混合导航（实验性）"**面板：

#### 1. `enableHybridNavigation` (默认: false)
- **作用**：启用混合导航系统
- **建议**：
  - 开阔场景 → 关闭（使用纯网格模式）
  - 复杂场景/狭窄通道 → 开启

#### 2. `complexAreaThreshold` (默认: 3)
- **作用**：复杂区域判定阈值（周围障碍物数量）
- **调整建议**：
  - 值越小 → 越容易触发连续导航
  - 值越大 → 越保守，多用网格导航
  - 推荐范围：2-5

#### 3. `continuousNavRadius` (默认: 3.0)
- **作用**：连续导航检测半径（米）
- **说明**：在这个半径内检测障碍物并计算排斥力
- **调整建议**：
  - 狭窄通道 → 2.0-2.5
  - 开阔区域 → 3.0-4.0

#### 4. `obstacleRepulsionStrength` (默认: 2.0)
- **作用**：障碍物排斥力强度
- **调整建议**：
  - 值越大 → 越远离障碍物（更安全但可能绕远）
  - 值越小 → 路径更直接（但可能贴墙）
  - 推荐范围：1.5-3.0

#### 5. `ignoreDynamicUnits` (默认: false)
- **作用**：是否忽略动态单位（NPC/怪物）
- **说明**：为未来NPC/怪物导航预留
- **建议**：暂时保持false

### NavGrid2D配置

确保正确配置以支持混合导航：

```csharp
probeRadius = 玩家碰撞体半径  // 自动同步
cellSize = 0.5f              // 根据场景调整
strictCornerCutting = true   // 防止穿墙
```

---

## 使用方法

### 基础使用（玩家导航）

#### 1. 启用混合导航

```csharp
// 在PlayerAutoNavigator上勾选：
enableHybridNavigation = true
```

#### 2. 配置障碍物检测

确保以下任意一项已配置：

- **方法A（推荐）**：使用Tag
  ```csharp
  losObstacleTags = ["Buildings", "Rocks", "Trees"]
  ```

- **方法B**：使用LayerMask
  ```csharp
  losObstacleMask = Obstacles层
  ```

#### 3. 测试场景

创建测试场景验证：

1. **狭窄通道测试**：
   - 通道宽度 ≈ 玩家碰撞体直径 + 0.05米
   - 点击通道另一端
   - **预期**：玩家顺利通过，不卡墙

2. **极限转弯测试**：
   - 创建"之"字形狭窄通道
   - **预期**：平滑转弯，不碰撞

3. **障碍物交叠测试**：
   - 如你的树林场景（红色区域内有空隙）
   - **预期**：能找到并通过空隙

---

## NPC/怪物扩展

### 为NPC添加导航能力

#### 方法1：使用NavigationUnitBase基类

```csharp
using UnityEngine;

public class NPCNavigator : NavigationUnitBase
{
    private PlayerAutoNavigator navigator;  // 复用导航逻辑
    
    protected override void Awake()
    {
        base.Awake();
        unitType = NavigationUnitType.NPC;
        
        // 添加并配置PlayerAutoNavigator组件
        navigator = gameObject.AddComponent<PlayerAutoNavigator>();
        // ... 配置navigator
    }
    
    public void MoveTo(Vector3 destination)
    {
        navigator.SetDestination(destination);
    }
}
```

#### 方法2：实现INavigationUnit接口

```csharp
public class EnemyAI : MonoBehaviour, INavigationUnit
{
    public NavigationUnitType GetUnitType() => NavigationUnitType.Enemy;
    
    public Vector2 GetPosition() => transform.position;
    
    public float GetColliderRadius()
    {
        var col = GetComponent<Collider2D>();
        return col ? Mathf.Max(col.bounds.extents.x, col.bounds.extents.y) : 0.25f;
    }
    
    public bool ShouldAvoid(INavigationUnit other)
    {
        // 敌人避让玩家和其他敌人
        var type = other.GetUnitType();
        return type == NavigationUnitType.Player || type == NavigationUnitType.Enemy;
    }
    
    public float GetAvoidanceRadius() => 0.6f;
}
```

### 单位类型说明

```csharp
NavigationUnitType.Player       // 玩家：最高优先级
NavigationUnitType.NPC          // 友好NPC：互相避让
NavigationUnitType.Enemy        // 敌对单位：与玩家/NPC避让
NavigationUnitType.StaticObstacle // 静态障碍物
```

---

## 技术细节

### 算法流程

#### Grid模式（网格寻路）
```
1. 使用NavGrid2D.TryFindPath生成路径
2. 路径合并（避免方向突变）
3. 视线优化（跳过可直达路径点）
4. AdjustDirectionByColliders微调
5. 输出移动方向
```

#### Continuous模式（连续空间）
```
1. IsInComplexArea判断是否在复杂区域
2. CalculateContinuousNavigation:
   a. 计算目标吸引力
   b. CalculateRepulsiveForce计算障碍物排斥力
   c. 合成最终方向
3. FindPassableDirection验证路径:
   a. 尝试期望方向
   b. 尝试±15°, ±30°, ±45°...
   c. 使用CircleCast检测每个方向
4. 输出移动方向
```

### 性能优化

- **Grid模式**：O(n²) A*寻路，适合开阔区域
- **Continuous模式**：O(k) k=周围障碍物数量，适合复杂区域
- **自动切换**：最大化效率

### CircleCast优势

```csharp
// 传统网格：只检查中心点
Physics2D.OverlapCircle(gridCenter, radius)  // ❌ 丢失边缘信息

// CircleCast：沿路径连续检测
Physics2D.CircleCast(from, radius, direction, distance)  // ✅ 精确检测
```

---

## 故障排查

### 问题1：导航不生效

**症状**：启用混合导航后，玩家不动

**排查步骤**：
1. 检查`enableHybridNavigation`是否为true
2. 检查`losObstacleTags`或`losObstacleMask`是否配置
3. 查看Console是否有错误
4. 确认NavGrid2D已正确初始化

**解决方案**：
```csharp
// 在PlayerAutoNavigator.Awake中添加调试日志
Debug.Log($"Hybrid Nav: {enableHybridNavigation}, Tags: {losObstacleTags?.Length}");
```

---

### 问题2：仍然会卡在狭窄通道

**症状**：启用混合导航后，仍然卡墙

**原因**：
- `complexAreaThreshold`太高，未触发Continuous模式
- `continuousNavRadius`太小，检测不到障碍物

**解决方案**：
```csharp
// 调整参数
complexAreaThreshold = 2;        // 降低阈值
continuousNavRadius = 2.5f;      // 增加检测半径
obstacleRepulsionStrength = 2.5f; // 增加排斥力
```

---

### 问题3：路径太绕远

**症状**：玩家绕大圈，不走直线

**原因**：排斥力太强

**解决方案**：
```csharp
obstacleRepulsionStrength = 1.5f;  // 降低排斥力
```

---

### 问题4：Gizmos不显示导航模式

**说明**：当前版本暂未添加Continuous模式的可视化

**计划**：未来版本将添加：
- 橙色线：Continuous模式路径
- 黄色圆圈：检测到的障碍物
- 绿色箭头：排斥力方向

---

## 版本历史

### v4.0 (2024-12-04)
- ✅ 实现混合导航系统
- ✅ 添加连续空间导航（势场法）
- ✅ 添加CircleCast精确碰撞检测
- ✅ 为NPC/怪物预留接口
- ✅ 完全向后兼容

### v3.2.4 (之前)
- 路径稳定性修复
- 起点查找算法优化
- 碰撞体脱困功能

---

## 最佳实践

### 1. 关卡设计建议

- **狭窄通道**：宽度 >= 玩家直径 + 0.1米
- **避免极限情况**：尽量不要让碰撞体边缘完全重叠
- **测试路径**：每个关卡至少测试10个导航路径

### 2. 性能建议

- 开阔区域 → 关闭混合导航（使用纯Grid模式）
- 只在必要时启用Continuous模式
- 定期清理不必要的碰撞体

### 3. 调试建议

```csharp
// 在Update中添加调试信息
void OnDrawGizmos()
{
    if (!showPathGizmos) return;
    
    // 显示当前导航模式
    string mode = currentNavigationMode.ToString();
    UnityEditor.Handles.Label(transform.position + Vector3.up, $"Mode: {mode}");
}
```

---

## 后续计划

- [ ] 添加Continuous模式的可视化调试
- [ ] 实现NPC群体导航（Flocking）
- [ ] 优化性能：缓存CircleCast结果
- [ ] 支持动态障碍物实时响应

---

**如有问题，请查阅故障排查章节或联系技术支持。**
