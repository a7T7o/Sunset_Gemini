# å¯¼èˆªæ¨¡å—å®Œæ•´æ–¹æ¡ˆ

**æ¨¡å—åç§°**: 2D A* å¯¼èˆªç³»ç»Ÿ  
**ç‰ˆæœ¬**: v3.3  
**æœ€åæ›´æ–°**: 2025å¹´12æœˆ  
**ç›¸å…³æ–‡ä»¶**: 
- `Assets/Scripts/Service/Navigation/NavGrid2D.cs`
- `Assets/Scripts/Service/Navigation/INavigationUnit.cs`
- `Assets/Scripts/Service/Player/PlayerAutoNavigator.cs`

---

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

### åŠŸèƒ½å®šä½
ä¸º 2D å†œåœºæ¨¡æ‹Ÿæ¸¸æˆæä¾›å®Œæ•´çš„å¯¼èˆªè§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒï¼š
- å³é”®ç‚¹å‡»è‡ªåŠ¨å¯»è·¯
- è·Ÿéšç›®æ ‡ç§»åŠ¨
- åŠ¨æ€éšœç¢ç‰©é¿è®©
- æ ‘æ—/å»ºç­‘ç­‰å¤æ‚åœ°å½¢å¯¼èˆª

### æ ¸å¿ƒç»„ä»¶

| ç»„ä»¶ | èŒè´£ |
|------|------|
| `NavGrid2D` | ç½‘æ ¼æ„å»ºã€A* å¯»è·¯ç®—æ³•ã€éšœç¢ç‰©æ£€æµ‹ |
| `PlayerAutoNavigator` | è·¯å¾„æ‰§è¡Œã€è§†çº¿ä¼˜åŒ–ã€ç¢°æ’é¢„è­¦ |
| `INavigationUnit` | å¯¼èˆªå•ä½æ¥å£ï¼ˆé¢„ç•™ç»™ NPC/æ€ªç‰©ï¼‰ |

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ•´ä½“æµç¨‹

```
ç”¨æˆ·å³é”®ç‚¹å‡»
    â”‚
    â†“
GameInputManager æ£€æµ‹ç‚¹å‡»
    â”‚
    â†“
PlayerAutoNavigator.SetDestination(worldPos)
    â”‚
    â”œâ”€ ç›®æ ‡ç‚¹å»æŠ–æ£€æµ‹ï¼ˆ<0.3m å¿½ç•¥ï¼‰
    â”‚
    â†“
RebuildPath()
    â”‚
    â”œâ”€ èµ·ç‚¹ä¿®æ­£ï¼ˆå¦‚æœåœ¨éšœç¢ç‰©å†…ï¼‰
    â”œâ”€ NavGrid2D.TryFindPath() â†’ A* å¯»è·¯
    â”œâ”€ è·¯å¾„åˆå¹¶ï¼ˆä¿ç•™ç§»åŠ¨è¿ç»­æ€§ï¼‰
    â””â”€ æ¸…ç†èº«åè·¯å¾„ç‚¹
    â”‚
    â†“
Update() æ¯å¸§æ‰§è¡Œ
    â”‚
    â”œâ”€ è§†çº¿ä¼˜åŒ–ï¼ˆè·³è¿‡å¯ç›´è¾¾çš„ç‚¹ï¼‰
    â”œâ”€ ç¢°æ’é¢„è­¦ï¼ˆæ£€æµ‹å‰æ–¹éšœç¢ç‰©ï¼‰
    â”œâ”€ æ–¹å‘å¾®è°ƒï¼ˆé¿å¼€å‘¨å›´éšœç¢ç‰©ï¼‰
    â””â”€ ç§»åŠ¨æ‰§è¡Œ
```

### æ•°æ®æµ

```
ä¸–ç•Œåæ ‡ â†’ WorldToGrid() â†’ ç½‘æ ¼åæ ‡
                â†“
         A* å¯»è·¯ç®—æ³•
                â†“
ç½‘æ ¼è·¯å¾„ â†’ GridToWorldCenter() â†’ ä¸–ç•Œè·¯å¾„
                â†“
         è§†çº¿ä¼˜åŒ– + ç¢°æ’é¢„è­¦
                â†“
         PlayerMovement.SetMovementInput()
```

---

## ğŸ“ æ ¸å¿ƒæ–‡ä»¶è¯¦è§£

### 1. NavGrid2D.cs

#### èŒè´£
- æ„å»ºå¯¼èˆªç½‘æ ¼
- è‡ªåŠ¨æ£€æµ‹ä¸–ç•Œè¾¹ç•Œ
- A* å¯»è·¯ç®—æ³•
- éšœç¢ç‰©æ£€æµ‹

#### å…³é”®é…ç½®å‚æ•°

```csharp
[Header("ç½‘æ ¼è®¾ç½®")]
[SerializeField] private float cellSize = 0.5f;           // ç½‘æ ¼å¤§å°ï¼ˆç±³ï¼‰
[SerializeField] private float probeRadius = 0.5f;        // éšœç¢ç‰©æ¢æµ‹åŠå¾„
[SerializeField] private bool eightDirections = true;     // 8æ–¹å‘ç§»åŠ¨
[SerializeField] private bool strictCornerCutting = true; // ä¸¥æ ¼å¯¹è§’çº¿æ£€æµ‹

[Header("ä¸–ç•Œè¾¹ç•Œè®¾ç½®")]
[SerializeField] private bool autoDetectWorldBounds = true;  // è‡ªåŠ¨æ£€æµ‹è¾¹ç•Œ
[SerializeField] private string[] worldLayerNames = { "LAYER 1", "LAYER 2", "LAYER 3" };
[SerializeField] private float boundsPadding = 5f;        // è¾¹ç•Œæ‰©å±•ä½™é‡

[Header("éšœç¢ç‰©æ ‡ç­¾")]
[SerializeField] private string[] obstacleTags = { "Tree", "Building", "Rock" };
```

#### æ ¸å¿ƒæ–¹æ³•


**1. è‡ªåŠ¨ä¸–ç•Œè¾¹ç•Œæ£€æµ‹**

```csharp
private void DetectWorldBounds()
{
    Bounds totalBounds = new Bounds();
    bool boundsInitialized = false;

    // 1. æ‰«ææ‰€æœ‰ Tilemap
    var tilemaps = FindObjectsByType<Tilemap>(FindObjectsSortMode.None);
    foreach (var tilemap in tilemaps)
    {
        if (!IsInWorldLayers(tilemap.transform)) continue;
        
        Bounds tilemapBounds = tilemap.localBounds;
        Vector3 worldMin = tilemap.transform.TransformPoint(tilemapBounds.min);
        Vector3 worldMax = tilemap.transform.TransformPoint(tilemapBounds.max);
        
        Bounds worldBounds = new Bounds();
        worldBounds.SetMinMax(worldMin, worldMax);
        
        if (!boundsInitialized) {
            totalBounds = worldBounds;
            boundsInitialized = true;
        } else {
            totalBounds.Encapsulate(worldBounds);
        }
    }

    // 2. æ‰«ææ‰€æœ‰ Collider2Dï¼ˆè¡¥å……ï¼‰
    var colliders = FindObjectsByType<Collider2D>(FindObjectsSortMode.None);
    foreach (var col in colliders)
    {
        if (!IsInWorldLayers(col.transform)) continue;
        if (col.CompareTag("Player") || col.name.Contains("(Clone)")) continue;
        totalBounds.Encapsulate(col.bounds);
    }

    // 3. æ‰©å±•è¾¹ç•Œå¹¶åº”ç”¨
    totalBounds.Expand(boundsPadding * 2f);
    worldOrigin = new Vector2(totalBounds.min.x, totalBounds.min.y);
    worldSize = new Vector2(totalBounds.size.x, totalBounds.size.y);
}
```

**2. æ™ºèƒ½èµ·å§‹ç‚¹æŸ¥æ‰¾**

```csharp
private bool FindSmartStartPoint(Vector2 playerPos, Vector2 targetPos, 
                                  int gx, int gy, out int nx, out int ny)
{
    Vector2 toTarget = (targetPos - playerPos).normalized;
    float bestScore = float.MinValue;
    
    for (int r = 1; r <= 10; r++)
    {
        for (int dx = -r; dx <= r; dx++)
        {
            for (int dy = -r; dy <= r; dy++)
            {
                if (Mathf.Abs(dx) != r && Mathf.Abs(dy) != r) continue;
                
                int x = gx + dx, y = gy + dy;
                if (!InBounds(x, y) || !IsWalkable(x, y)) continue;
                
                Vector2 candidateWorld = GridToWorldCenter(x, y);
                Vector2 toCandidate = (candidateWorld - playerPos).normalized;
                
                // è¯„åˆ†ï¼šæ–¹å‘æƒé‡70% + è·ç¦»æƒé‡30%
                float directionScore = Vector2.Dot(toCandidate, toTarget);
                float distanceScore = 1f / (1f + Mathf.Sqrt(dx*dx + dy*dy));
                float score = directionScore * 7f + distanceScore * 3f;
                
                if (score > bestScore) {
                    bestScore = score;
                    nx = x; ny = y;
                }
            }
        }
        if (bestScore > float.MinValue) break;
    }
    return bestScore > float.MinValue;
}
```

**3. ä¸¥æ ¼å¯¹è§’çº¿æ£€æµ‹**

```csharp
private bool TryMakeDiagonal(int x, int y, int dx, int dy, out Vector2Int result)
{
    int nx = x + dx, ny = y + dy;
    if (!InBounds(nx, ny)) { result = default; return false; }
    
    // ä¸¤æ¡ç›¸é‚»è¾¹å¿…é¡»å¯èµ°
    if (!IsWalkable(x + dx, y) || !IsWalkable(x, y + dy))
    {
        result = default;
        return false;
    }
    
    // å¯¹è§’æ ¼æœ¬èº«å¿…é¡»å¯èµ°
    if (!IsWalkable(nx, ny)) { result = default; return false; }
    
    // ä¸¥æ ¼æ¨¡å¼ï¼šæ£€æŸ¥å¯¹è§’çº¿ä¸­ç‚¹
    if (strictCornerCutting)
    {
        Vector2 from = GridToWorldCenter(x, y);
        Vector2 to = GridToWorldCenter(nx, ny);
        Vector2 mid = (from + to) * 0.5f;
        if (IsPointBlocked(mid, probeRadius * 0.5f))
        {
            result = default;
            return false;
        }
    }
    
    result = new Vector2Int(nx, ny);
    return true;
}
```

**4. å…¨å±€åˆ·æ–°äº‹ä»¶**

```csharp
// ä»»ä½•è„šæœ¬éƒ½å¯ä»¥è§¦å‘ç½‘æ ¼åˆ·æ–°
public static System.Action OnRequestGridRefresh;

void Awake()
{
    OnRequestGridRefresh += RefreshGrid;
}

void OnDestroy()
{
    OnRequestGridRefresh -= RefreshGrid;
}

// ä½¿ç”¨æ–¹å¼ï¼ˆå¦‚ TreeControllerï¼‰
NavGrid2D.OnRequestGridRefresh?.Invoke();
```

---

### 2. PlayerAutoNavigator.cs

#### èŒè´£
- è·¯å¾„æ‰§è¡Œå’Œç®¡ç†
- è§†çº¿ä¼˜åŒ–
- ç¢°æ’é¢„è­¦
- æ–¹å‘å¾®è°ƒ

#### å…³é”®é…ç½®å‚æ•°

```csharp
[Header("åœæ­¢/å®¹å·®")]
[SerializeField] private float stopDistance = 0.2f;        // ç»ˆç‚¹åœæ­¢è·ç¦»
[SerializeField] private float waypointTolerance = 0.1f;   // è·¯å¾„ç‚¹å®¹å·®

[Header("æ™ºèƒ½è·¯å¾„æ›´æ–°")]
[SerializeField] private bool enableSmartPathUpdate = true;
[SerializeField] private float destinationChangeThreshold = 0.3f;  // ç›®æ ‡ç‚¹å»æŠ–
[SerializeField] private bool enablePathMerging = true;            // è·¯å¾„åˆå¹¶
[SerializeField] private float pathMergeThreshold = 0.5f;          // åˆå¹¶é˜ˆå€¼

[Header("è§†çº¿ä¼˜åŒ–")]
[SerializeField] private bool enableLineOfSightOptimization = true;
[SerializeField] private LayerMask losObstacleMask;        // å¿…é¡»é…ç½®ï¼
[SerializeField] private float losCheckRadius = 0.3f;
[SerializeField] private string[] losObstacleTags;         // å¿…é¡»é…ç½®ï¼
[SerializeField] private float safetyMargin = 0.2f;        // å®‰å…¨è¾¹è·
```

#### æ ¸å¿ƒæ–¹æ³•


**1. æ–¹å‘å¾®è°ƒï¼ˆv3.3 ä¼˜åŒ–ç‰ˆï¼‰**

```csharp
private Vector2 AdjustDirectionByColliders(Vector2 pos, Vector2 desiredDir)
{
    if (playerCollider == null) return desiredDir;
    float playerRadius = Mathf.Max(playerCollider.bounds.extents.x, 
                                   playerCollider.bounds.extents.y);
    
    // å¤šç‚¹å‰ç»é‡‡æ ·ï¼ˆè¿‘ã€ä¸­ã€è¿œï¼‰
    float[] aheadDistances = runWhileNavigating 
        ? new float[] { 0.15f, 0.35f, 0.6f }
        : new float[] { 0.1f, 0.25f, 0.45f };
    
    float clearance = playerRadius + 0.05f;
    Vector2 totalRepulse = Vector2.zero;
    
    foreach (float ahead in aheadDistances)
    {
        Vector2 probe = pos + desiredDir * ahead;
        var hits = Physics2D.OverlapCircleAll(probe, clearance);
        float weight = 1f / (ahead + 0.1f);  // è¿‘ç‚¹æƒé‡é«˜
        
        foreach (var h in hits)
        {
            if (!IsObstacle(h)) continue;
            
            Vector2 cp = h.ClosestPoint(probe);
            Vector2 away = probe - cp;
            float d = Mathf.Max(away.magnitude, 0.01f);
            
            // å¹³æ–¹åæ¯”æ’æ–¥åŠ›
            float repulseStrength = 1f / (d * d + 0.1f);
            totalRepulse += away.normalized * repulseStrength * weight;
        }
    }
    
    if (totalRepulse.sqrMagnitude < 0.0001f) return desiredDir;
    
    // é™åˆ¶æœ€å¤§åè½¬è§’åº¦ï¼ˆ60åº¦ï¼‰
    Vector2 corrected = (desiredDir + totalRepulse * 0.8f).normalized;
    float angle = Vector2.SignedAngle(desiredDir, corrected);
    if (Mathf.Abs(angle) > 60f)
    {
        corrected = RotateVector(desiredDir, Mathf.Sign(angle) * 60f);
    }
    
    return corrected;
}
```

**2. è§†çº¿æ£€æµ‹ï¼ˆv3.3 ä¸‰å±‚æ£€æµ‹ï¼‰**

```csharp
private bool HasLineOfSight(Vector2 from, Vector2 to)
{
    Vector2 direction = to - from;
    float distance = direction.magnitude;
    if (distance < 0.01f) return true;
    
    float playerRadius = playerCollider != null 
        ? Mathf.Max(playerCollider.bounds.extents.x, playerCollider.bounds.extents.y)
        : 0.25f;
    
    // æ›´å¯†é›†é‡‡æ ·ï¼ˆæ¯0.3ç±³ï¼‰
    int sampleCount = Mathf.Max(3, Mathf.CeilToInt(distance / 0.3f));
    Vector2 perpendicular = new Vector2(-direction.y, direction.x).normalized;
    
    bool PathClearWith(float checkRadius, bool useSideSampling)
    {
        for (int i = 0; i <= sampleCount; i++)
        {
            float t = i / (float)sampleCount;
            Vector2 centerPoint = Vector2.Lerp(from, to, t);
            
            // ä¸‰ç‚¹æ£€æµ‹ï¼šä¸­å¿ƒ + ä¸¤ä¾§
            Vector2[] samplePoints = useSideSampling
                ? new Vector2[] {
                    centerPoint,
                    centerPoint + perpendicular * playerRadius * 0.7f,
                    centerPoint - perpendicular * playerRadius * 0.7f
                  }
                : new Vector2[] { centerPoint };
            
            foreach (var point in samplePoints)
            {
                var hits = Physics2D.OverlapCircleAll(point, checkRadius);
                foreach (var hit in hits)
                {
                    if (IsObstacle(hit)) return false;
                }
            }
        }
        return true;
    }
    
    // ä¸‰å±‚æ£€æµ‹ç­–ç•¥
    float safeRadius = playerRadius + safetyMargin;
    if (PathClearWith(safeRadius, true)) return true;           // ä¸¥æ ¼
    
    float mediumRadius = playerRadius + safetyMargin * 0.5f;
    if (PathClearWith(mediumRadius, false)) return true;        // ä¸­ç­‰
    
    float tightRadius = playerRadius + 0.02f;
    return PathClearWith(tightRadius, false);                   // ç‹­çª„é€šé“
}
```

**3. ç¢°æ’é¢„è­¦ç³»ç»Ÿï¼ˆv3.3 æ–°å¢ï¼‰**

```csharp
private bool CheckCollisionAhead(Vector2 pos, Vector2 direction)
{
    if (playerCollider == null) return false;
    
    float playerRadius = Mathf.Max(playerCollider.bounds.extents.x, 
                                   playerCollider.bounds.extents.y);
    float lookAheadDistance = runWhileNavigating ? 0.5f : 0.35f;
    
    RaycastHit2D[] hits = Physics2D.CircleCastAll(
        pos,
        playerRadius + 0.05f,
        direction.normalized,
        lookAheadDistance
    );
    
    foreach (var hit in hits)
    {
        if (hit.collider == playerCollider) continue;
        if (hit.transform.IsChildOf(player)) continue;
        
        if (IsObstacle(hit.collider))
        {
            return true;  // å‰æ–¹æœ‰éšœç¢ç‰©
        }
    }
    
    return false;
}

// åœ¨ Update() ä¸­ä½¿ç”¨
if (CheckCollisionAhead(pos, dir))
{
    if (pathIndex > 0)
    {
        pathIndex--;  // å›é€€åˆ°ä¸Šä¸€ä¸ªå®‰å…¨è·¯å¾„ç‚¹
        target = path[pathIndex];
        dir = (target - pos).normalized;
    }
}
```

**4. è·¯å¾„åˆå¹¶ç®—æ³•**

```csharp
private void MergePathWithOld(List<Vector2> oldPath, int oldPathIndex)
{
    if (path.Count == 0 || oldPath.Count == 0) return;
    
    Vector2 playerPos = playerCollider.bounds.center;
    
    // é€Ÿåº¦è‡ªé€‚åº”
    float playerSpeed = runWhileNavigating ? 4f : 2f;
    float speedFactor = Mathf.Max(1f, playerSpeed / 2f);
    float arrivalThreshold = 0.15f * speedFactor;
    
    Vector2 currentTarget = oldPath[oldPathIndex];
    float distanceToTarget = Vector2.Distance(playerPos, currentTarget);
    
    // å‰ç»ï¼šè·³è¿‡å³å°†åˆ°è¾¾çš„ç‚¹
    while (distanceToTarget < arrivalThreshold && oldPathIndex + 1 < oldPath.Count)
    {
        oldPathIndex++;
        currentTarget = oldPath[oldPathIndex];
        distanceToTarget = Vector2.Distance(playerPos, currentTarget);
    }
    
    // åœ¨æ–°è·¯å¾„ä¸­æŸ¥æ‰¾é‡åˆç‚¹
    float dynamicMergeThreshold = pathMergeThreshold * speedFactor;
    int bestMatchIndex = -1;
    float bestMatchDist = dynamicMergeThreshold;
    
    Vector2 playerMovementDir = (currentTarget - playerPos).normalized;
    
    for (int i = 0; i < path.Count; i++)
    {
        float dist = Vector2.Distance(path[i], currentTarget);
        if (dist < bestMatchDist)
        {
            Vector2 toMatchPoint = path[i] - playerPos;
            float alignment = Vector2.Dot(playerMovementDir, toMatchPoint.normalized);
            
            if (alignment > 0f || toMatchPoint.magnitude < 0.2f)
            {
                bestMatchDist = dist;
                bestMatchIndex = i;
            }
        }
    }
    
    if (bestMatchIndex >= 0)
    {
        pathIndex = bestMatchIndex;
        // è·³è¿‡èº«åæˆ–è¿‡è¿‘çš„ç‚¹...
    }
    else
    {
        CleanupPathBehindPlayer();
    }
}
```

---

## ğŸ”„ ç‰ˆæœ¬è¿­ä»£å†å²

### v1.0 - åŸºç¡€å®ç°
- A* å¯»è·¯ç®—æ³•
- æ‰‹åŠ¨é…ç½®ä¸–ç•Œè¾¹ç•Œ
- åŸºç¡€è·¯å¾„æ‰§è¡Œ

### v2.0 - ä¸–ç•Œè¾¹ç•Œè‡ªåŠ¨æ£€æµ‹
- è‡ªåŠ¨æ‰«æ Tilemap å’Œ Collider è¾¹ç•Œ
- å±‚çº§è¿‡æ»¤ï¼ˆLAYER 1/2/3ï¼‰
- åŠ¨æ€éšœç¢ç‰©åŒæ­¥ï¼ˆå…¨å±€äº‹ä»¶ï¼‰

### v3.0 - é¢‘ç¹ç‚¹å‡»é¬¼ç•œä¿®å¤
- è·¯å¾„åˆå¹¶ç®—æ³•
- ç›®æ ‡ç‚¹å»æŠ–
- èº«åè·¯å¾„ç‚¹æ¸…ç†
- è§†çº¿ä¼˜åŒ–

### v3.1 - é€Ÿåº¦è‡ªé€‚åº”
- æ ¹æ®ç§»åŠ¨é€Ÿåº¦åŠ¨æ€è°ƒæ•´å‰ç»è·ç¦»
- é€Ÿåº¦å› å­å½±å“å„ç§é˜ˆå€¼

### v3.2 - å®‰å…¨è¾¹è·æ£€æµ‹
- è§†çº¿ä¼˜åŒ–å¢åŠ å®‰å…¨è¾¹è·
- é˜²æ­¢è´´å¢™/å¡å¢™

### v3.3 - å…¨é¢ä¼˜åŒ–ï¼ˆå½“å‰ç‰ˆæœ¬ï¼‰
- å¤šç‚¹å‰ç»é‡‡æ ·
- ä¸‰å±‚è§†çº¿æ£€æµ‹
- ç¢°æ’é¢„è­¦ç³»ç»Ÿ
- æœ€å¤§åè½¬è§’åº¦é™åˆ¶
- æ›´ä¿å®ˆçš„è·³ç‚¹ç­–ç•¥

---

## âš™ï¸ é…ç½®æŒ‡å—

### NavGrid2D æ¨èé…ç½®

```
ç½‘æ ¼è®¾ç½®:
â”œâ”€ Cell Size: 0.5ï¼ˆå¹³è¡¡ç²¾åº¦ä¸æ€§èƒ½ï¼‰
â”œâ”€ Probe Radius: 0.5~0.6ï¼ˆç•¥å¤§äºç©å®¶ï¼‰
â”œâ”€ Eight Directions: âœ…
â””â”€ Strict Corner Cutting: âœ…

ä¸–ç•Œè¾¹ç•Œè®¾ç½®:
â”œâ”€ Auto Detect World Bounds: âœ…
â”œâ”€ World Layer Names: ["LAYER 1", "LAYER 2", "LAYER 3"]
â””â”€ Bounds Padding: 5

éšœç¢ç‰©æ ‡ç­¾:
â””â”€ Obstacle Tags: ["Tree", "Building", "Rock"]
```

### PlayerAutoNavigator æ¨èé…ç½®

```
åœæ­¢/å®¹å·®:
â”œâ”€ Stop Distance: 0.2
â””â”€ Waypoint Tolerance: 0.1

æ™ºèƒ½è·¯å¾„æ›´æ–°:
â”œâ”€ Enable Smart Path Update: âœ…
â”œâ”€ Destination Change Threshold: 0.3
â”œâ”€ Enable Path Merging: âœ…
â””â”€ Path Merge Threshold: 0.5

è§†çº¿ä¼˜åŒ–:
â”œâ”€ Enable Line Of Sight Optimization: âœ…
â”œâ”€ Los Obstacle Mask: ã€å¿…é¡»ä¸NavGrid2Dç›¸åŒã€‘
â”œâ”€ Los Check Radius: 0.3
â”œâ”€ Los Obstacle Tags: ["Tree", "Building", "Rock"]
â””â”€ Safety Margin: 0.3~0.5
```

---

## ğŸ› å¸¸è§é—®é¢˜æ’æŸ¥

### é—®é¢˜1ï¼šå¯¼èˆªæ— å“åº”
**å¯èƒ½åŸå› **ï¼š
- ä¸–ç•Œè¾¹ç•Œæœªè¦†ç›–ç‚¹å‡»ä½ç½®
- èµ·ç‚¹/ç»ˆç‚¹åœ¨éšœç¢ç‰©å†…

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å¯ç”¨ `logObstacleDetection` æŸ¥çœ‹è¾¹ç•Œ
2. æ£€æŸ¥ `autoDetectWorldBounds` æ˜¯å¦å¯ç”¨
3. ç¡®è®¤åœºæ™¯ç»“æ„ç¬¦åˆ LAYER 1/2/3

### é—®é¢˜2ï¼šè·¯å¾„ç©¿å¢™
**å¯èƒ½åŸå› **ï¼š
- `losObstacleMask` æœªé…ç½®
- `losObstacleTags` æœªé…ç½®
- `strictCornerCutting` æœªå¯ç”¨

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ç¡®ä¿ `losObstacleMask` ä¸ NavGrid2D çš„ `obstacleMask` ç›¸åŒ
2. ç¡®ä¿ `losObstacleTags` åŒ…å«æ‰€æœ‰éšœç¢ç‰©æ ‡ç­¾
3. å¯ç”¨ `strictCornerCutting`

### é—®é¢˜3ï¼šé¢‘ç¹ç‚¹å‡»é¬¼ç•œ
**å¯èƒ½åŸå› **ï¼š
- è·¯å¾„åˆå¹¶æœªå¯ç”¨
- ç›®æ ‡ç‚¹å»æŠ–é˜ˆå€¼è¿‡å°

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å¯ç”¨ `enablePathMerging`
2. å¢å¤§ `destinationChangeThreshold`ï¼ˆ0.3~0.5ï¼‰

### é—®é¢˜4ï¼šæ’åˆ°éšœç¢ç‰©
**å¯èƒ½åŸå› **ï¼š
- è§†çº¿ä¼˜åŒ–è¿‡äºæ¿€è¿›
- å®‰å…¨è¾¹è·è¿‡å°

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å¢å¤§ `safetyMargin`ï¼ˆ0.4~0.6ï¼‰
2. å‡å°è§†çº¿ä¼˜åŒ–çš„è·³ç‚¹è·ç¦»

### é—®é¢˜5ï¼šè·¯å¾„ç»•è¿œ
**å¯èƒ½åŸå› **ï¼š
- `cellSize` è¿‡å¤§
- éšœç¢ç‰©æ£€æµ‹è¿‡äºä¿å®ˆ

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å‡å° `cellSize`ï¼ˆ0.3~0.5ï¼‰
2. å‡å° `probeRadius`

---

## ğŸ“Š æ€§èƒ½å‚è€ƒ

| åœºæ™¯å¤§å° | æ ¼å­æ•°é‡ | é‡å»ºæ—¶é—´ | å†…å­˜å ç”¨ |
|---------|---------|---------|---------|
| 50Ã—50 | 10,000 | ~50ms | ~200KB |
| 100Ã—80 | 32,000 | ~150ms | ~640KB |
| 200Ã—200 | 160,000 | ~800ms | ~3.2MB |

**æ¨è**ï¼š100Ã—80 åœºæ™¯ï¼ŒcellSize=0.5

---

## ğŸ”— ç›¸å…³ç³»ç»Ÿé›†æˆ

### TreeController é›†æˆ
```csharp
// æ ‘æœ¨æˆé•¿æ—¶é€šçŸ¥å¯¼èˆªç½‘æ ¼åˆ·æ–°
private void UpdateColliderState()
{
    // ... ç¢°æ’ä½“çŠ¶æ€å˜åŒ–æ£€æµ‹ ...
    
    if (hadEnabledCollider != hasEnabledCollider)
    {
        // å»¶è¿Ÿ0.2ç§’åˆ·æ–°ï¼Œé¿å…é¢‘ç¹è°ƒç”¨
        Invoke(nameof(TriggerNavGridRefresh), 0.2f);
    }
}

private void TriggerNavGridRefresh()
{
    NavGrid2D.OnRequestGridRefresh?.Invoke();
}
```

### SprintStateManager é›†æˆ
```csharp
// å¯¼èˆªæ—¶åŒæ­¥ç–¾è·‘çŠ¶æ€
if (SprintStateManager.Instance != null)
{
    SprintStateManager.Instance.OnMovementInput(true);
    runWhileNavigating = SprintStateManager.Instance.ShouldNavigationSprint();
}
```

---

## ğŸ“ ç»´æŠ¤å»ºè®®

1. **å®šæœŸæ£€æŸ¥**ï¼šç¡®ä¿ `losObstacleMask` å’Œ `losObstacleTags` ä¸åœºæ™¯éšœç¢ç‰©ä¸€è‡´
2. **æ€§èƒ½ç›‘æ§**ï¼šå¤§åœºæ™¯æ³¨æ„ç½‘æ ¼é‡å»ºæ—¶é—´
3. **è°ƒè¯•å·¥å…·**ï¼šä½¿ç”¨ `showPathGizmos` å’Œ `showDebugGizmos` å¯è§†åŒ–è°ƒè¯•
4. **ç‰ˆæœ¬æ§åˆ¶**ï¼šä¿®æ”¹æ ¸å¿ƒç®—æ³•å‰å¤‡ä»½

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.3  
**ç»´æŠ¤è€…**: Kiro AI Assistant  
**é¡¹ç›®**: Sunset 2D å†œåœºæ¨¡æ‹Ÿæ¸¸æˆ
