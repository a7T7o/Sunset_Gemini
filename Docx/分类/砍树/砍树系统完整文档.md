# 砍树系统完整文档

版本: v1.0
日期: 2025-12-22
状态: **已完成**

---

## 目录

1. [系统概述](#系统概述)
2. [架构设计](#架构设计)
3. [核心组件](#核心组件)
4. [命中检测机制](#命中检测机制)
5. [接口设计](#接口设计)
6. [数据结构](#数据结构)
7. [关键算法](#关键算法)
8. [配置参数](#配置参数)
9. [调试工具](#调试工具)
10. [常见问题](#常见问题)
11. [相关文件清单](#相关文件清单)

---

## 系统概述

砍树系统是工具-资源交互框架的核心实现，负责处理玩家使用斧头砍伐树木的完整流程。

### 核心功能

1. **精确命中检测** - 基于 Collider Bounds 的三重验证机制
2. **工具-资源匹配** - 只有斧头能对树木造成伤害
3. **血量系统** - 树木有血量，砍伐时减少
4. **倒下动画** - 树木被砍倒时播放倒下动画
5. **掉落物生成** - 砍倒后生成木材等掉落物
6. **精力消耗** - 砍树消耗玩家精力

### 设计原则

1. **零改动现有预制体** - 使用 Sprite/Collider Bounds 检测，不依赖额外碰撞体
2. **帧索引触发** - 利用现有动画系统的帧同步机制（第3-4帧触发命中）
3. **可扩展架构** - 通过 IResourceNode 接口支持新资源类型

---

## 架构设计

### 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                   PlayerToolHitEmitter                       │
│                     （命中发射器）                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  帧索引     │  │  扇形计算   │  │   三重验证          │  │
│  │  检测       │→ │  (60°锥形) │→ │   (Collider+位置)   │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   ResourceNodeRegistry                       │
│                    （资源节点注册表）                         │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  Dictionary<int, IResourceNode> 存储所有资源节点     │    │
│  │  - Register(node, instanceId)                       │    │
│  │  - Unregister(instanceId)                           │    │
│  │  - GetNodesInRange(position, radius)                │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      IResourceNode                           │
│                     （资源节点接口）                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ CanAccept() │  │  OnHit()    │  │  GetColliderBounds()│  │
│  │ (工具匹配)  │  │ (命中处理)  │  │  (精确边界)         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
         TreeController  TreeControllerV2  StoneController
         (树木控制器)    (树木控制器V2)   (矿石控制器)
```

### 数据流

```
玩家挥砍动画 → 帧索引检测(3-4帧) → 获取范围内节点 → 三重验证
                                                      │
                                                      ▼
                                              ┌───────────────┐
                                              │ A. Collider   │
                                              │    扇形检测   │
                                              └───────┬───────┘
                                                      │
                                                      ▼
                                              ┌───────────────┐
                                              │ B. 位置验证   │
                                              │ (朝向+相对位置)│
                                              └───────┬───────┘
                                                      │
                                                      ▼
                                              ┌───────────────┐
                                              │ C. 单目标选择 │
                                              │ (最近距离)    │
                                              └───────┬───────┘
                                                      │
                                                      ▼
                                              调用 OnHit() 处理命中
```

---

## 核心组件

### 1. PlayerToolHitEmitter（命中发射器）

**文件位置**: `Assets/Scripts/Combat/PlayerToolHitEmitter.cs`

**职责**:
- 检测动画帧索引，在命中窗口内触发检测
- 执行三重验证（扇形检测、位置验证、单目标选择）
- 构建 ToolHitContext 并调用资源节点的 OnHit 方法
- 绘制调试 Gizmos

**关键字段**:

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| wedgeAngleDeg | float | 60 | 扇形角度（度） |
| defaultReach | float | 1.5 | 命中距离（米） |
| hitWindowStart | int | 3 | 命中窗口起始帧 |
| hitWindowEnd | int | 4 | 命中窗口结束帧 |
| playerCollider | Collider2D | - | 玩家碰撞体（用于获取中心点） |

### 2. ResourceNodeRegistry（资源节点注册表）

**文件位置**: `Assets/Scripts/Combat/ResourceNodeRegistry.cs`

**职责**:
- 管理所有可交互资源节点的注册和注销
- 提供基于距离的快速查询

**使用方式**:
```csharp
// 注册（在 Start 中）
ResourceNodeRegistry.Instance.Register(this, gameObject.GetInstanceID());

// 注销（在 OnDestroy 中）
ResourceNodeRegistry.Instance.Unregister(gameObject.GetInstanceID());

// 查询范围内节点
var nodes = ResourceNodeRegistry.Instance.GetNodesInRange(origin, reach);
```

### 3. TreeController / TreeControllerV2（树木控制器）

**文件位置**: 
- `Assets/Scripts/Controller/TreeController.cs`
- `Assets/Scripts/Controller/TreeControllerV2.cs`

**职责**:
- 实现 IResourceNode 接口
- 管理树木状态（正常、枯萎、树桩等）
- 处理命中效果（抖动、树叶、音效）
- 管理血量和砍倒逻辑
- 播放倒下动画

---

## 命中检测机制

### 三重验证机制（核心！）

命中检测采用三重验证机制，确保只有符合逻辑的目标才会被命中：

#### A. Collider Bounds 扇形检测

```csharp
private bool CheckWedgeBoundsIntersection(Vector2 origin, Vector2 forward, 
    float reach, float angleDeg, Bounds bounds)
{
    // 1. 获取 Collider bounds 的最近点
    Vector2 closestPoint = bounds.ClosestPoint(origin);
    
    // 2. 检查距离
    float distSqr = (closestPoint - origin).sqrMagnitude;
    if (distSqr > reach * reach) return false;
    
    // 3. 检查角度
    Vector2 toClosest = (closestPoint - origin).normalized;
    float angle = Vector2.Angle(forward, toClosest);
    if (angle > angleDeg * 0.5f) return false;
    
    return true;
}
```

**关键点**:
- ✅ 使用 **Collider bounds** 而非 Sprite bounds
- ✅ 树木的 Collider 只覆盖树根部分，更精确
- ✅ 无 Collider 时回退到 Sprite bounds

#### B. 玩家朝向与相对位置验证

```csharp
private bool ValidatePositionRelation(Vector2 playerCenter, int direction, 
    bool flipX, Bounds colliderBounds)
{
    const float tolerance = 0.1f;
    
    switch (direction)
    {
        case 0: // Down - 玩家必须在目标上方
            return playerCenter.y > colliderBounds.max.y - tolerance;
            
        case 1: // Up - 玩家必须在目标下方
            return playerCenter.y < colliderBounds.min.y + tolerance;
            
        case 2: // Side
            if (flipX) // 朝左 - 玩家必须在目标右侧
                return playerCenter.x > colliderBounds.max.x - tolerance;
            else // 朝右 - 玩家必须在目标左侧
                return playerCenter.x < colliderBounds.min.x + tolerance;
            
        default:
            return false;
    }
}
```

**位置验证规则表**:

| 玩家朝向 | Direction | FlipX | 位置要求 | 说明 |
|---------|-----------|-------|---------|------|
| 朝下 | 0 | - | playerY > collider.max.y - 0.1 | 玩家在树上方 |
| 朝上 | 1 | - | playerY < collider.min.y + 0.1 | 玩家在树下方 |
| 朝右 | 2 | false | playerX < collider.min.x + 0.1 | 玩家在树左侧 |
| 朝左 | 2 | true | playerX > collider.max.x - 0.1 | 玩家在树右侧 |

**图示**:
```
朝下 (Direction=0)              朝上 (Direction=1)
    玩家 ●                           ┌───┐
         ↓                           │树木│
    ┌───┐                            └───┘
    │树木│                               ↑
    └───┘                            玩家 ●
    
朝右 (Direction=2, FlipX=false)  朝左 (Direction=2, FlipX=true)
    玩家 ● →  ┌───┐                  ┌───┐  ← ● 玩家
              │树木│                  │树木│
              └───┘                  └───┘
```

#### C. 单目标选择

```csharp
// 从通过验证的节点中选择最近的一个
if (validCandidates.Count > 0)
{
    // 按 Collider 中心距离排序
    validCandidates.Sort((a, b) => a.distance.CompareTo(b.distance));
    var closest = validCandidates[0];
    
    // 只命中最近的一个
    closest.node.OnHit(ctx);
}
```

**关键点**:
- ✅ 使用 **Collider 中心到 Collider 中心** 的距离
- ✅ 不是最近点距离
- ✅ 多棵树距离相同时命中第一个检测到的

---

## 接口设计

### IResourceNode 接口

```csharp
namespace FarmGame.Combat
{
    public interface IResourceNode
    {
        /// <summary>检查是否接受此工具类型（用于判断是否扣血）</summary>
        bool CanAccept(ToolHitContext ctx);
        
        /// <summary>处理命中（抖动、扣血、特效等）</summary>
        void OnHit(ToolHitContext ctx);
        
        /// <summary>获取检测边界（Sprite Bounds）</summary>
        Bounds GetBounds();
        
        /// <summary>获取碰撞体边界（用于精确命中检测）</summary>
        /// <returns>Collider bounds，无 Collider 时回退到 Sprite bounds</returns>
        Bounds GetColliderBounds();
        
        /// <summary>获取资源位置（树根位置）</summary>
        Vector3 GetPosition();
        
        /// <summary>资源是否已耗尽</summary>
        bool IsDepleted { get; }
        
        /// <summary>资源类型标识</summary>
        string ResourceTag { get; }
    }
}
```

### GetColliderBounds 实现示例

```csharp
public Bounds GetColliderBounds()
{
    // 优先使用 Collider2D 的 bounds
    Collider2D collider = GetComponent<Collider2D>();
    if (collider != null && collider.enabled)
    {
        return collider.bounds;
    }
    
    // 检查父物体的 CompositeCollider2D
    if (transform.parent != null)
    {
        var compositeCollider = transform.parent.GetComponent<CompositeCollider2D>();
        if (compositeCollider != null && compositeCollider.enabled)
        {
            return compositeCollider.bounds;
        }
    }
    
    // 回退到 Sprite bounds
    return GetBounds();
}
```

---

## 数据结构

### ToolHitContext（命中上下文）

```csharp
public struct ToolHitContext
{
    public int toolItemId;        // 工具物品ID
    public int toolQuality;       // 工具品质（已弃用，默认0）
    public ToolType toolType;     // 工具类型枚举
    public int materialTier;      // 材料等级（0=木, 1=石, 2=生铁, 3=黄铜, 4=钢, 5=金）
    public int actionState;       // 动画状态（挥砍=6, 挖掘=8）
    public Vector2 hitPoint;      // 命中点
    public Vector2 hitDir;        // 命中方向
    public GameObject attacker;   // 攻击者
    public float baseDamage;      // 基础伤害
    public int frameIndex;        // 命中帧索引
}
```

### 树木层级结构（关键！）

```
Tree_M1_00（父物体）
├─ 位置 = 树根 = 种植点（游戏逻辑位置）
├─ Layer = Default
├─ Rigidbody2D (Static)
├─ CompositeCollider2D (物理碰撞用)
├─ OcclusionTransparency
│
├─ Tree（子物体，TreeController 所在）
│    ├─ SpriteRenderer（渲染位置）
│    ├─ PolygonCollider2D (Merge) ← 只覆盖树根！
│    └─ TreeController
│
└─ Shadow（子物体）
     └─ SpriteRenderer（阴影）
```

**⚠️ 重要**:
- 树木的 **PolygonCollider2D 只覆盖树根部分**，不是整个树冠
- 命中检测使用 **Collider bounds**，所以只有靠近树根才能砍到
- 这是设计意图，不是 bug

---

## 关键算法

### 倒下方向判定

```csharp
private FallDirection DetermineFallDirection(int playerDirection, bool playerFlipX)
{
    switch (playerDirection)
    {
        case 0: // Down
            return playerFlipX ? FallDirection.Left : FallDirection.Right;
        case 1: // Up
            return playerFlipX ? FallDirection.Right : FallDirection.Left;
        case 2: // Side
            return FallDirection.Up;
        default:
            return FallDirection.Right;
    }
}
```

**倒下方向判定表**:

| 玩家朝向 | Direction | FlipX | 倒下方向 |
|---------|-----------|-------|---------|
| 朝下 | 0 | false | 向右倒 |
| 朝下 | 0 | true | 向左倒 |
| 朝上 | 1 | false | 向左倒 |
| 朝上 | 1 | true | 向右倒 |
| 朝左/右 | 2 | - | 向上倒 |

### Direction 参数映射（全局统一）

**⚠️ 重要**：Direction 参数来自 `PlayerAnimController.ConvertToAnimatorDirection()`

```csharp
// 正确映射
AnimDirection.Down  => 0  // Direction=0 表示朝下
AnimDirection.Up    => 1  // Direction=1 表示朝上（不是 Side！）
AnimDirection.Right => 2  // Direction=2 表示朝左/右（Side）
AnimDirection.Left  => 2  // Direction=2 表示朝左/右（Side）
```

**常见错误**：误以为 `1=Side, 2=Up`，实际上是 `1=Up, 2=Side`！

---

## 配置参数

### PlayerToolHitEmitter 参数

| 参数 | 默认值 | 范围 | 说明 |
|------|--------|------|------|
| wedgeAngleDeg | 60 | 30-120 | 扇形角度（度） |
| defaultReach | 1.5 | 0.5-3.0 | 命中距离（米） |
| hitWindowStart | 3 | 0-7 | 命中窗口起始帧 |
| hitWindowEnd | 4 | 0-7 | 命中窗口结束帧 |
| POSITION_TOLERANCE | 0.1 | - | 位置验证容差值 |

### TreeController 砍伐参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| chopCountSmall | 3 | 小树需要砍伐的次数 |
| chopCountLarge | 7 | 大树需要砍伐的次数 |
| fallDuration | 0.8 | 倒下动画时长（秒） |
| enableFallAnimation | true | 是否启用倒下动画 |

---

## 调试工具

### Gizmos 绘制

PlayerToolHitEmitter 在 Scene 视图中绘制：

1. **橙色扇形** - 攻击范围
2. **蓝色箭头** - 玩家朝向
3. **绿色线** - 扇形中心线
4. **红色球** - 命中点
5. **黄色箭头** - 倒下方向

### 调试日志

启用 `showDebugInfo` 后输出：

```
[PlayerToolHitEmitter] ========== 命中检测开始 ==========
  玩家中心: (x, y)
  玩家朝向: Down (Direction=0, FlipX=false)
  朝向向量: (0, -1)
  攻击范围: 1.5
  扇形角度: 60°
  范围内节点数: 3

[命中检测详情]
  玩家中心: (x, y)
  树木Bounds中心: (x, y)
  树木Bounds范围: min(x, y) ~ max(x, y)
  最近点: (x, y)
  位置关系: 上方 + 左侧
  距离: 1.2 (限制: 1.5) → ✓
  角度: 25° (限制: ±30°) → ✓
  结果: 命中

[PlayerToolHitEmitter] ✓ 命中: Tree，距离: 1.2
```

---

## 常见问题

### Q1: 为什么树木明明在扇形范围内却砍不到？

**A**: 检查以下几点：
1. 树木的 **Collider** 是否在扇形内（不是 Sprite）
2. 玩家位置是否符合朝向逻辑（朝下时必须在树上方）
3. 是否有其他树木更近被优先选中

### Q2: 为什么使用 Collider bounds 而不是 Sprite bounds？

**A**: 树木的 Sprite 很大（包含整个树冠），但 Collider 只覆盖树根。使用 Collider bounds 可以：
- 更精确地判断玩家是否真的靠近树木
- 避免远距离就能砍到树的问题
- 符合物理碰撞的逻辑

### Q3: Direction 参数的映射是什么？

**A**: 
- 0 = Down（朝下）
- 1 = Up（朝上）
- 2 = Side（朝左/右，根据 FlipX 判断）

**注意**：不是 0=Down, 1=Side, 2=Up！

### Q4: 如何添加新的资源类型？

**A**: 
1. 创建新的控制器类，实现 `IResourceNode` 接口
2. 在 `Start` 中注册到 `ResourceNodeRegistry`
3. 在 `OnDestroy` 中注销
4. 实现 `GetColliderBounds()` 返回精确边界

---

## 相关文件清单

### 核心脚本

| 文件 | 说明 |
|------|------|
| `Assets/Scripts/Combat/PlayerToolHitEmitter.cs` | 命中发射器 |
| `Assets/Scripts/Combat/ResourceNodeRegistry.cs` | 资源节点注册表 |
| `Assets/Scripts/Interfaces/IResourceNode.cs` | 资源节点接口 |
| `Assets/Scripts/Controller/TreeController.cs` | 树木控制器 |
| `Assets/Scripts/Controller/TreeControllerV2.cs` | 树木控制器 V2 |
| `Assets/Scripts/Controller/StoneController.cs` | 矿石控制器 |

### 配置文件

| 文件 | 说明 |
|------|------|
| `Assets/Scripts/Data/ToolResourceConfig.cs` | 工具-资源交互配置 |
| `Assets/Scripts/Data/DropTable.cs` | 掉落表配置 |

### 特效脚本

| 文件 | 说明 |
|------|------|
| `Assets/Scripts/Effects/LeafSpawner.cs` | 树叶生成器 |
| `Assets/Scripts/Effects/LeafFallEffect.cs` | 树叶飘落效果 |

### 规范文档

| 文件 | 说明 |
|------|------|
| `.kiro/specs/tree-chopping-system/requirements.md` | 需求文档 |
| `.kiro/specs/tree-chopping-system/design.md` | 设计文档 |
| `.kiro/specs/tree-chopping-system/tasks.md` | 任务清单 |
| `.kiro/specs/tree-chopping-system/memory.md` | 开发记忆 |
| `.kiro/steering/trees.md` | 树木系统规范 |
| `.kiro/steering/layers.md` | 层级设计规范 |

---

## 更新历史

| 版本 | 日期 | 更新内容 |
|------|------|---------|
| v1.0 | 2025-12-22 | 初始版本，包含精确命中检测三重验证机制 |

---

## 作者

Kiro AI Assistant

