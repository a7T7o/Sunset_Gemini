# 交接文档完整合集

**版本**: v1.0  
**日期**: 2025-12-16  
**状态**: 已合并

---

## 目录

1. [农田系统交接](#1-农田系统交接)
2. [遮挡透明与云朵阴影系统交接](#2-遮挡透明与云朵阴影系统交接)
3. [物品系统交接](#3-物品系统交接)
4. [工具栏与工具联动交接](#4-工具栏与工具联动交接)
5. [动画系统交接（Pivot对话）](#5-动画系统交接pivot对话)
6. [核心系统优化交接](#6-核心系统优化交接)

---

# 1. 农田系统交接

## 1.1 系统概述

### 设计目标
- 实现完整的农田管理系统，支持耕种、浇水、作物生长和收获
- 支持3种土壤湿度视觉状态：干燥、湿润带水洼、湿润深色
- 与游戏时间系统集成，作物生长按天计算

### 主要特点
- **灵活的Tilemap系统**：支持不同状态的耕地显示
- **时间驱动**：作物生长与游戏时间系统集成
- **状态管理**：完整的土壤湿度和作物生长状态管理

## 1.2 核心功能

### 耕地系统
- 使用Unity Tilemap实现耕地地块
- 支持三种状态：未开垦、已开垦、已浇水
- 地块数据持久化存储

### 种植系统
- 支持多种作物类型
- 不同作物有不同的生长周期和季节适应性
- 支持重复收获的作物（如蓝莓）

### 浇水系统
三种水分状态：
- 干燥（未浇水）
- 湿润带水洼（浇水后2小时内）
- 湿润深色（浇水2小时后到第二天）

## 1.3 技术实现

### 时间系统集成
```csharp
// 订阅时间事件
TimeManager.OnDayChanged += OnDayChanged;  // 签名: (int year, int day, int totalDays)
TimeManager.OnHourChanged += OnHourChanged; // 签名: (int hour)

// 取消订阅
private void OnDestroy() {
    TimeManager.OnDayChanged -= OnDayChanged;
    TimeManager.OnHourChanged -= OnHourChanged;
}
```

### 季节判断逻辑
```csharp
private bool IsCorrectSeason(SeedData seedData)
{
    if (timeManager == null) return true;
    
    if (seedData.season == Season.AllSeason)
        return true;

    // ItemEnums.Season: Spring=0, Summer=1, Fall=2, Winter=3
    // SeasonManager.Season: Spring=0, Summer=1, Autumn=2, Winter=3
    SeasonManager.Season currentSeason = timeManager.GetSeason();
    return (int)seedData.season == (int)currentSeason;
}
```

### 数据结构

#### FarmTileData
```csharp
public bool isTilled;              // 是否已耕作
public bool wateredToday;          // 今天是否浇水
public bool wateredYesterday;      // 昨天是否浇水
public float waterTime;            // 浇水时间（小时）
public SoilMoistureState moistureState;  // 当前湿度状态
public CropInstance crop;          // 作物实例
```

#### SoilMoistureState
```csharp
public enum SoilMoistureState
{
    Dry,           // 干燥
    WetWithPuddle, // 湿润带水洼（浇水后2小时内）
    WetDark        // 湿润深色（浇水2小时后）
}
```

## 1.4 已解决问题

### TimeManager API不匹配
```csharp
// ❌ 错误：使用实例方法访问静态事件
timeManager.OnDayChanged += OnDayChanged;

// ✅ 正确：使用静态事件访问
TimeManager.OnDayChanged += OnDayChanged;
```

### FarmTileData字段重构
```csharp
// 旧字段
public bool isWatered;
public int lastWateredDay;

// 新字段
public bool wateredToday;
public bool wateredYesterday;
public float waterTime;
public SoilMoistureState moistureState;
```

## 1.5 待办事项

### 高优先级
- [ ] 实现ItemDatabase访问
- [ ] 添加精力值消耗逻辑
- [ ] 完善收获功能

### 中优先级
- [ ] 添加更多作物类型
- [ ] 实现季节变化效果
- [ ] 添加音效和粒子效果

---

# 2. 遮挡透明与云朵阴影系统交接

## 2.1 系统概述

### 遮挡透明
- 玩家被遮挡时，遮挡物透明
- 树木：渐变透明（根0.8→干0.5→叶0.3）
- 其他物体（房子、岩石等）：统一透明
- 阴影（Shadow）不受透明影响

### 云朵阴影
- 晴天/多云时渲染"移动的云影"
- 置于世界物体之上（UI之下）
- 与遮挡透明系统解耦

## 2.2 核心架构

### 文件路径
- `Assets/Scripts/Service/Rendering/OcclusionManager.cs`
- `Assets/Scripts/Service/Rendering/OcclusionTransparency.cs`
- `Assets/Editor/OcclusionManagerEditor.cs`
- `Assets/Editor/OcclusionTransparencyEditor.cs`

### 组件职责
- **OcclusionManager**：集中管理全局透明参数、检测逻辑、调试输出
- **OcclusionTransparency**：挂在可遮挡物体上，OnEnable读取一次Manager参数

## 2.3 运行时流程

### 检测流程
1. 获取玩家 `Bounds`（优先 `playerSprite.bounds`）
2. 按检测半径过滤
3. 标签过滤：`useTagFilter` + `occludableTags`
4. 同 Sorting Layer 过滤（可选）
5. `Bounds.Intersects` 判定是否遮挡
6. 遮挡成立 → `SetOccluding(true)`

### 关键参数
```csharp
[SerializeField, Range(1f, 5f)] private float rootConnectionDistance = 2.5f;
[SerializeField, Range(5, 100)] private int maxForestSearchDepth = 50;
[SerializeField, Range(5f, 30f)] private float maxForestSearchRadius = 15f;
```

## 2.4 树木渐变透明 Shader

### 设计要点
- 未遮挡时与 `Sprites/Default` 完全一致
- 遮挡时才使用垂直渐变（根→干→叶）
- 使用"预乘输出"避免整块矩形罩子

### 参数建议
- `Bottom Alpha = 0.8`、`Middle Alpha = 0.5`、`Top Alpha = 0.3`
- `Split1 = 0.33`、`Split2 = 0.66`、`Softness = 0.05`

## 2.5 云朵阴影系统（方案A）

### 功能特性
- ✅ 精灵云影对象池
- ✅ 随机位置/缩放/速度
- ✅ 循环移动与自动回收
- ⏳ 天气系统联动（待接入）

### 参数说明
| 参数 | 类型 | 说明 |
|------|------|------|
| `enableCloudShadows` | bool | 总开关 |
| `intensity` | [0-1] | 云影透明度 |
| `density` | [0-1] | 云影密度 |
| `scaleRange` | Vector2 | 随机缩放范围 |
| `direction` | Vector2 | 移动方向 |
| `speed` | float | 移动速度 |

### 天气联动
- Sunny：开启，Intensity=0.25~0.4
- PartlyCloudy：低强度/低密度
- Overcast/Rain/Snow：关闭

## 2.6 树木层级结构规范

```
Tree_M1_00（父物体）
├─ Tree（子物体）
│    ├─ SpriteRenderer（赋"渐变材质"）
│    └─ OcclusionTransparency
└─ Shadow（子物体）
     └─ SpriteRenderer（默认材质）
```

---

# 3. 物品系统交接

## 3.1 系统概述

### 游戏定位
- **类型**: 混合型农场RPG（战斗为主，轻度经营）
- **核心玩法**: 洞穴探险战斗 + 简单种田 + 交易系统
- **参考游戏**: 《符文工房》系列 + 《星露谷物语》元素

### 核心循环
```
早上醒来（精力满）
    ↓
种田/浇水（消耗精力）→ 几天后收获作物
    ↓
作物 → 烹饪 → 食物（恢复精力/体力）
    ↓
进入洞穴挖矿/打怪（消耗精力/体力）
    ↓
获得矿石/怪物素材 → 出售赚钱 or 制作药水
    ↓
金币 → 买种子/装备 → 扩大生产
```

## 3.2 物品数据架构

### 核心文件
```
Assets/Scripts/Data/
├── Enums/ItemEnums.cs           - 所有枚举定义
├── Items/
│   ├── ItemData.cs              - 物品基类
│   ├── SeedData.cs              - 种子数据类
│   ├── CropData.cs              - 作物数据类
│   ├── FoodData.cs              - 食物数据类
│   ├── ToolData.cs              - 工具数据类
│   ├── WeaponData.cs            - 武器数据类
│   ├── MaterialData.cs          - 材料数据类
│   └── PotionData.cs            - 药水数据类
├── Recipes/RecipeData.cs        - 配方数据类
└── Database/ItemDatabase.cs     - 物品数据库管理器
```

### ID分配规范
```
0XXX: 工具和武器
    00XX: 农业工具 (锄头、水壶、镰刀、钓鱼竿)
    01XX: 采集工具 (镐子、斧头)
    02XX: 武器 (剑、弓、法杖)

1XXX: 种植类
    10XX: 种子
    11XX: 作物

2XXX: 动物产品
3XXX: 矿物和材料
4XXX: 消耗品（药水）
5XXX: 食品
6XXX: 家具
7XXX: 特殊物品
```

## 3.3 品质系统

### 品质等级
- Normal (普通) - 倍率 1.0
- Copper (铜星) - 倍率 1.25
- Silver (银星) - 倍率 1.5
- Gold (金星) - 倍率 2.0
- Iridium (彩星) - 倍率 2.5

### 设计原则
- 品质不改变外观，只在UI显示星星
- 不同品质物品不能堆叠
- 收获时根据等级和肥料随机判定品质

### 使用示例
```csharp
// 收获作物时随机品质
ItemQuality quality = QualityHelper.RandomCropQuality(playerLevel, usedFertilizer);

// 计算售价
int finalPrice = QualityHelper.CalculatePriceWithQuality(basePrice, quality);

// 获取星星颜色（用于UI）
Color starColor = QualityHelper.GetQualityStarColor(quality);
```

## 3.4 自动化工具

### 菜单命令
```
Farm → Setup → 完整初始化（推荐）          # 一键创建所有基础数据
Farm → Setup → 创建主物品数据库           # 只创建数据库
Farm → Items → 批量创建物品数据 (SO)      # 批量生成各类物品数据
```

### 数据库操作
```
右键 MasterItemDatabase.asset
→ 自动收集所有物品数据
→ 自动收集所有配方数据
→ 验证所有数据完整性
```

## 3.5 动画ID映射（v3.2新增）

### ToolData/WeaponData 新增字段
- `useQualityIdMapping (bool)`：是否启用品质到默认动画ID的映射
- `animationDefaultId (int)`：启用映射时用于命名/匹配的默认ID
- `GetAnimationKeyId()`：返回用于动画匹配的ID

### 使用示例
工具A 不同品质ID：101/102/103
- 若映射启用且默认ID=101
- 则三者动画均使用 `{...}_Clip_101_{quality}`

---

# 4. 工具栏与工具联动交接

## 4.1 系统架构

### 组件职责
| 组件 | 职责 |
|------|------|
| ToolbarUI | 工具栏容器，管理所有槽位 |
| ToolbarSlotUI | 单个槽位UI，处理点击事件 |
| HotbarSelectionService | 管理选中索引，触发装备 |
| InventoryService | 背包数据管理 |
| GameInputManager | 输入检测，触发工具使用 |
| PlayerToolController | 设置工具Animator参数 |

## 4.2 工具选中流程

```
用户点击工具栏槽位
    ↓
ToolbarSlotUI.OnPointerClick()
    ↓
HotbarSelectionService.SelectIndex(index)
    ↓
EquipCurrentTool()
    ↓
playerToolController.EquipToolData(toolData, quality)
```

## 4.3 工具使用流程

```
用户左键点击世界空间
    ↓
GameInputManager.HandleUseCurrentTool()
    ↓
检测 IsPointerOverGameObject() → 如果在UI上则返回
    ↓
playerInteraction.RequestAction(action)
    ↓
animController.PlayAnimation(action, direction, flip)
```

## 4.4 工具类型到动画映射

```csharp
ToolType.Axe → AnimState.Slice        // 斧头 → 挥砍
ToolType.Sickle → AnimState.Slice     // 镰刀 → 挥砍
ToolType.Pickaxe → AnimState.Crush    // 镐子 → 挖掘
ToolType.Hoe → AnimState.Crush        // 锄头 → 挖掘
ToolType.WateringCan → AnimState.Watering  // 洒水壶 → 浇水
ToolType.FishingRod → AnimState.Fish  // 鱼竿 → 钓鱼
```

## 4.5 ScriptableObject 引用获取

### 正确做法
```csharp
// ItemDatabase 是 ScriptableObject，不是单例
// 从已有引用的 MonoBehaviour 获取
if (inventory != null)
    database = inventory.Database;
```

### 错误做法
```csharp
// ❌ 永远返回 null
database = FindFirstObjectByType<ItemDatabase>();
```

## 4.6 输入系统

### 工具栏快捷键
| 按键 | 功能 |
|------|------|
| 1-5 | 选中对应槽位 (0-4) |
| 滚轮上 | 选中上一个槽位 |
| 滚轮下 | 选中下一个槽位 |
| 左键点击槽位 | 选中该槽位 |

---

# 5. 动画系统交接（Pivot对话）

## 5.1 项目目标

1. **完美动画同步**：消除玩家手部动画与工具动画之间的1-2帧延迟
2. **正确的工具显示层级**：确保斧头始终显示在玩家的下方
3. **健壮可复用的动画同步方案**：支持未来更复杂的工具层级结构
4. **精确的 Sprite Pivot 设置工具**：批量修正切割后 Sprite 的 Pivot

## 5.2 关键组件

| 组件 | 职责 |
|------|------|
| LayerAnimSync.cs | 动画同步核心，负责Tool Animator的速度控制、参数同步 |
| PlayerAnimController.cs | 控制玩家动画，设置Animator参数 |
| AxeAnimController.cs | 控制斧头动画 |
| SlicePivotCopyTool.cs | 批量复制和调整 Sprite 的 Pivot |
| LayerAnimSetupTool.cs | 生成动画剪辑并修正帧数 |

## 5.3 动画同步方案

### Mode A++ 帧索引硬锁
1. 从 Player 的 Sprite 名称解析帧号
2. 按帧数比例映射到 Tool 帧号
3. 使用 `Play(hash, normalizedTime) + Update(0)` 实现当帧同步
4. 添加极小正偏置避免边界抖动

### 精确帧同步代码
```csharp
// 在 LateUpdate() 中
var playerState = playerAnimator.GetCurrentAnimatorStateInfo(0);
float exactTime = playerState.normalizedTime;
toolAnimator.Play(toolState.fullPathHash, 0, exactTime);
toolAnimator.Update(0);
```

## 5.4 Sprite Pivot 设置工具

### 偏移修正复制方案
```csharp
// 1. 源pivot（归一化） → 像素坐标
Vector2 sourcePivotPixel = new Vector2(
    sourceFrames[i].pivotNormalized.x * sourceFrames[i].rectSize.x,
    sourceFrames[i].pivotNormalized.y * sourceFrames[i].rectSize.y
);

// 2. 应用offset
Vector2 targetPivotPixel = sourcePivotPixel - offset;

// 3. 像素坐标 → 归一化坐标
Vector2 targetPivotNormalized = new Vector2(
    targetPivotPixel.x / targetSprites[i].rect.width,
    targetPivotPixel.y / targetSprites[i].rect.height
);
```

## 5.5 已解决问题

### 动画卡在第0帧
- **原因**：`toolAnimator.Play()` 频繁调用与 `toolAnimator.speed = 1.0f` 冲突
- **解决**：设置 `toolAnimator.speed = 0f`，手动调用 `Play()` 和 `Update(0)`

### 动画剪辑帧数问题
- **问题**：生成的动画剪辑总帧数始终为60帧
- **解决**：正确设置 `totalFrames / 60fps` 作为动画时长

---

# 6. 核心系统优化交接

## 6.1 交接范围

### 树林遮挡透明系统优化
- **问题**：玩家被遮挡时，独立树木和远处树木被错误连接成片
- **解决**：实现精确的树林连通性判定

### 导航系统世界边界修复
- **问题**：导航网格只覆盖摄像机视野，动态障碍物变化不同步
- **解决**：自动检测世界边界，事件驱动的动态更新机制

## 6.2 核心修改文件

| 文件路径 | 修改类型 | 说明 |
|---------|---------|------|
| OcclusionManager.cs | 重构 | 树林连通判定逻辑完全重写 |
| NavGrid2D.cs | 增强 | 新增自动边界检测和事件系统 |
| TreeController.cs | 增强 | 新增导航网格同步机制 |

## 6.3 树林连通性判定

### 双重可选条件
```csharp
// 满足任一条件即为连通
if (rootDistance <= rootConnectionDistance) return true;  // 树根距离近
if (overlapRatio >= 0.15f) return true;                 // 树冠重叠显著
return false;
```

## 6.4 导航系统世界边界

### 自动边界检测
```csharp
[SerializeField] private bool autoDetectWorldBounds = true;
[SerializeField] private string[] worldLayerNames = {"LAYER 1", "LAYER 2", "LAYER 3"};
[SerializeField] private float boundsPadding = 5f;
```

### 全局事件系统
```csharp
// 任何脚本都可以触发网格刷新
public static System.Action OnRequestGridRefresh;
NavGrid2D.OnRequestGridRefresh?.Invoke();
```

### 树木成长同步
```csharp
// TreeController 自动检测碰撞体状态变化
if (hadEnabledCollider != hasEnabledCollider)
{
    RequestNavGridRefresh();  // 延迟 0.2 秒刷新
}
```

## 6.5 性能影响

### 树林遮挡系统
| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| 连通判定准确性 | 60% | 95% |
| 误判率 | 高 | 极低 |

### 导航系统
| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| 覆盖范围 | 摄像机视野 | 整个世界 |
| 动态更新 | 不支持 | 自动同步 |
| 网格重建时间 | 不定 | <200ms |

---

# 附录：相关文档索引

| 文档 | 路径 | 内容 |
|------|------|------|
| 农田系统完整文档 | `Docx/农田/农田系统完整文档.md` | 农田系统详细设计 |
| 遮挡与导航完整文档 | `Docx/遮挡与导航/遮挡与导航系统完整文档.md` | 遮挡与导航详细设计 |
| UI系统完整文档 | `Docx/界面UI/UI系统完整文档.md` | UI系统详细设计 |
| 动画系统完整文档 | `Docx/人物与工具动画/动画系统完整文档.md` | 动画系统详细设计 |
| 树木系统完整文档 | `Docx/树木/树木系统完整文档.md` | 树木系统详细设计 |
| 项目全局文档 | `Docx/全局/项目全局文档.md` | 项目整体架构 |

---

**文档合并完成时间**: 2025-12-16  
**原始文档数量**: 7个  
**合并后状态**: 按系统分类整理
