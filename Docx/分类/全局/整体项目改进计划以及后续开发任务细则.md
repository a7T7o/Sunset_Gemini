# Sunset 整体项目改进计划以及后续开发任务细则

**文档版本**: v1.0  
**创建时间**: 2024年12月9日  
**项目阶段**: 第一阶段完成（40%），进入第二阶段  
**审视范围**: 全项目代码、架构、文档、资源组织

---

## 📋 执行摘要

本文档基于对 Sunset 项目的全面审视，从代码架构、系统设计、性能优化、开发流程四个维度提出改进方案，并制定详细的后续开发任务细则。

**核心发现**：
- ✅ 项目基础架构扎实，核心系统（时间、动画、导航、UI）设计优秀
- ⚠️ 部分系统耦合度较高，需要进一步解耦
- ⚠️ 缺少统一的事件管理系统
- ⚠️ 性能优化空间较大（对象池、批处理）
- ⚠️ 测试与调试工具不足

**改进优先级**：
- P0（高优先级）：事件系统重构、对象池实现、树木遮挡联动
- P1（中优先级）：性能优化、调试工具完善、文档补充
- P2（低优先级）：代码规范统一、编辑器工具扩展

---

## 第一部分：架构层面改进方案

### 1.1 事件系统重构

**现状问题**：
- 当前使用 C# 静态事件（如 `TimeManager.OnDayChanged`）
- 事件分散在各个管理器中，缺少统一管理
- 订阅/取消订阅容易遗漏，导致内存泄漏
- 缺少事件优先级和延迟触发机制

**改进方案**：建立统一的事件总线系统

**核心设计**：

1. 创建 `EventBus.cs` 单例，支持泛型事件类型
2. 事件分类：GameEvent（游戏逻辑）、UIEvent（界面）、SystemEvent（系统）
3. 支持事件优先级（0-100）和延迟触发
4. 自动管理订阅生命周期（MonoBehaviour 销毁时自动取消订阅）
5. 提供事件历史记录（调试用）

**实现细节**：
```csharp
// 事件定义
public class DayChangedEvent : IGameEvent
{
    public int Year { get; set; }
    public int SeasonDay { get; set; }
    public int TotalDays { get; set; }
}

// 订阅方式
EventBus.Subscribe<DayChangedEvent>(OnDayChanged, priority: 10);

// 发布方式
EventBus.Publish(new DayChangedEvent { Year = 1, SeasonDay = 5, TotalDays = 35 });
```

**迁移策略**：
- 第一阶段：保留现有静态事件，EventBus 与之并行
- 第二阶段：逐步迁移核心系统到 EventBus
- 第三阶段：移除旧的静态事件

**预期收益**：
- 降低系统耦合度
- 便于调试和追踪事件流
- 避免内存泄漏
- 支持更复杂的事件逻辑

---

### 1.2 服务定位器模式

**现状问题**：
- 大量使用单例模式（Singleton）
- 单例之间存在循环依赖风险
- 难以进行单元测试（无法 Mock）
- 场景切换时单例生命周期管理复杂

**改进方案**：引入服务定位器（Service Locator）

**核心设计**：
1. 创建 `ServiceLocator.cs` 管理所有服务
2. 服务接口化（ITimeService、IInventoryService 等）
3. 支持服务注册、获取、替换
4. 支持作用域（Global、Scene、Temporary）
5. 提供服务依赖注入（可选）

**实现示例**：
```csharp
// 注册服务
ServiceLocator.Register<ITimeService>(new TimeManager());

// 获取服务
var timeService = ServiceLocator.Get<ITimeService>();

// 场景切换时清理
ServiceLocator.ClearScope(ServiceScope.Scene);
```

**迁移策略**：
- 保留现有单例，逐步迁移到服务定位器
- 优先迁移核心服务（Time、Inventory、Save）
- 新系统直接使用服务定位器

**预期收益**：
- 降低耦合，提高可测试性
- 便于场景切换管理
- 支持服务热替换（调试用）

---

### 1.3 数据与逻辑分离

**现状问题**：
- 部分脚本混合了数据、逻辑、表现
- ScriptableObject 与运行时数据混用
- 难以实现存档系统

**改进方案**：明确三层架构

**层级划分**：
1. **数据层**（Data）：ScriptableObject、配置、常量
2. **逻辑层**（Domain/Services）：游戏规则、业务逻辑
3. **表现层**（Presentation）：UI、动画、音效

**具体实施**：
- 创建运行时数据模型（RuntimeData）
- 所有游戏状态存储在运行时数据中
- ScriptableObject 仅作为配置模板
- UI 只读取运行时数据，不直接操作 SO

**示例**：
```csharp
// 配置（ScriptableObject）
public class CropData : ScriptableObject
{
    public int growthDays;
    public Sprite[] growthStages;
}

// 运行时数据
public class CropInstance
{
    public int cropDataId;
    public int currentStage;
    public DateTime plantedTime;
    public bool isWatered;
}

// 服务层
public class FarmingService
{
    private List<CropInstance> crops = new List<CropInstance>();
    
    public void PlantCrop(Vector3Int position, int cropDataId)
    {
        var crop = new CropInstance
        {
            cropDataId = cropDataId,
            currentStage = 0,
            plantedTime = DateTime.Now
        };
        crops.Add(crop);
    }
}
```

**预期收益**：
- 存档系统易于实现
- 数据可序列化
- 逻辑可单元测试
- 便于网络同步（未来多人模式）

---

## 第二部分：系统层面改进方案

### 2.1 树木成长与遮挡透明联动（P0）

**问题描述**：
- 当前树木成长后，遮挡透明组件未动态启用
- 树苗阶段不应参与遮挡检测
- 树桩状态应禁用遮挡

**解决方案**：在 TreeController 中统一管理

**实现步骤**：
1. 在 `OcclusionTransparency.cs` 中添加：
   ```csharp
   public void SetCanBeOccluded(bool canBeOccluded)
   {
       this.canBeOccluded = canBeOccluded;
       
       if (!canBeOccluded && isOccluding)
       {
           SetOccluding(false);
       }
   }
   ```

2. 在 `TreeController.cs` 的 `UpdateColliderState()` 中添加：
   ```csharp
   private OcclusionTransparency occlusionTransparency;
   
   void Awake()
   {
       occlusionTransparency = GetComponent<OcclusionTransparency>();
   }
   
   private void UpdateColliderState()
   {
       // ... 现有碰撞体逻辑 ...
       
       // 同步更新遮挡组件
       if (occlusionTransparency != null)
       {
           bool shouldOcclude = (currentStage == GrowthStage.Small || 
                                 currentStage == GrowthStage.Large) && 
                                currentState != TreeState.Stump;
           
           occlusionTransparency.SetCanBeOccluded(shouldOcclude);
       }
   }
   ```

**测试验证**：
- 树苗阶段：玩家站在树苗下方，树苗不透明
- 小树/大树阶段：玩家被遮挡时，树木透明
- 树桩状态：树桩不透明

**预期收益**：
- 逻辑统一，易于维护
- 性能更好（不需要每帧检测）
- 与现有系统无缝集成

---

### 2.2 对象池系统（P0）

**现状问题**：
- 掉落物、粒子效果频繁创建销毁
- 导致 GC 峰值，影响帧率
- 未来怪物、子弹等也会有此问题

**改进方案**：建立通用对象池系统

**核心设计**：

1. 创建 `ObjectPool<T>` 泛型类
2. 支持预热（Prewarm）和动态扩容
3. 支持对象重置接口（IPoolable）
4. 提供全局池管理器（PoolManager）
5. 编辑器可视化（查看池状态、使用率）

**实现示例**：
```csharp
public interface IPoolable
{
    void OnSpawn();
    void OnDespawn();
}

public class ObjectPool<T> where T : Component, IPoolable
{
    private Queue<T> pool = new Queue<T>();
    private T prefab;
    private Transform parent;
    
    public T Spawn(Vector3 position, Quaternion rotation)
    {
        T obj = pool.Count > 0 ? pool.Dequeue() : Object.Instantiate(prefab, parent);
        obj.transform.SetPositionAndRotation(position, rotation);
        obj.gameObject.SetActive(true);
        obj.OnSpawn();
        return obj;
    }
    
    public void Despawn(T obj)
    {
        obj.OnDespawn();
        obj.gameObject.SetActive(false);
        pool.Enqueue(obj);
    }
}
```

**应用场景**：
- 掉落物（DroppedItem）
- 粒子效果（泥土飞溅、水流）
- 怪物（Enemy）
- 子弹/箭矢（Projectile）
- UI 格子（InventorySlot）

**预期收益**：
- 减少 GC 压力，帧率更稳定
- 减少 Instantiate 开销
- 内存使用更可控

---

### 2.3 农田系统完善（P0）

**现状问题**：
- 农田系统尚未实现
- 需要与时间、季节、天气系统联动
- 需要考虑性能（大量作物）

**改进方案**：分层设计农田系统

**核心组件**：
1. **FarmingManager**（单例）
   - 管理所有耕地和作物
   - 订阅时间事件（每日更新）
   - 提供耕地/种植/浇水/收获接口

2. **FarmlandTile**（ScriptableObject）
   - 土地状态：Normal、Tilled、Watered、Planted
   - 对应的 Tile 资源

3. **CropInstance**（运行时数据）
   - 作物 ID、位置、生长阶段、浇水状态
   - 种植时间、上次浇水时间

4. **CropGrowth**（MonoBehaviour）
   - 挂载到作物 GameObject
   - 根据 CropInstance 更新外观
   - 处理成熟、枯萎、收获

**性能优化**：
- 使用 Tilemap 存储土地状态（不创建 GameObject）
- 作物使用对象池
- 每日更新分帧处理（避免卡顿）
- 只更新玩家视野内的作物外观

**数据结构**：
```csharp
public class FarmlandData
{
    public Vector3Int position;
    public FarmlandState state;
    public DateTime lastWateredTime;
    public CropInstance crop;
}

public class CropInstance
{
    public int cropDataId;
    public int currentStage;
    public DateTime plantedTime;
    public DateTime lastWateredTime;
    public bool isWatered;
    public CropQuality quality;
}
```

**预期收益**：
- 支持大规模农田（100+ 作物）
- 性能稳定（30+ FPS）
- 易于扩展（肥料、温室等）

---

### 2.4 存档系统设计（P1）

**现状问题**：
- 尚未实现存档功能
- 需要保存大量状态（背包、农田、时间等）
- 需要考虑版本兼容性

**改进方案**：JSON 序列化 + 版本管理

**核心设计**：
1. **SaveData 结构**
   ```csharp
   [Serializable]
   public class SaveData
   {
       public int version = 1;
       public PlayerData player;
       public InventoryData inventory;
       public WorldData world;
       public FarmData farm;
       public TimeData time;
   }
   ```

2. **SaveService**（单例）
   - `Save(int slotIndex)`：保存到指定槽位
   - `Load(int slotIndex)`：从槽位加载
   - `GetSaveInfo(int slotIndex)`：获取存档信息（不加载）
   - `DeleteSave(int slotIndex)`：删除存档

3. **版本兼容**
   - 每个子数据结构包含版本号
   - 提供迁移方法（MigrateFrom）
   - 缺失字段使用默认值

4. **保存时机**
   - 手动保存（设置页按钮）
   - 自动保存（每日结束、场景切换）
   - 退出游戏前保存

**安全措施**：
- 保存前备份旧存档
- 保存失败时回滚
- 存档文件加密（可选）
- 云存档支持（未来）

**预期收益**：
- 玩家可以随时保存/加载
- 支持多存档槽位（3个）
- 版本更新不丢失存档

---

### 2.5 音效系统完善（P1）

**现状问题**：
- 音效系统尚未实现
- 需要管理大量音效资源
- 需要支持音量控制、淡入淡出

**改进方案**：AudioManager + 音效池

**核心设计**：
1. **AudioManager**（单例）
   - BGM 管理（播放、切换、淡入淡出）
   - SFX 管理（播放、停止、音效池）
   - 音量控制（主音量、BGM、SFX 分开）
   - 音效分组（UI、动作、环境、战斗）

2. **音效池**
   - 预创建 10-20 个 AudioSource
   - 动态分配给 SFX
   - 播放完成后回收

3. **音效配置**
   ```csharp
   [CreateAssetMenu]
   public class SoundEffect : ScriptableObject
   {
       public AudioClip[] clips; // 支持随机变化
       public float volume = 1f;
       public float pitch = 1f;
       public float pitchVariation = 0.1f;
       public SoundGroup group;
   }
   ```

4. **空间音效**
   - 支持 3D 音效（距离衰减）
   - 环境音效（风声、鸟叫）根据位置播放

**预期收益**：
- 音效管理统一
- 性能优化（音效池）
- 支持复杂音效逻辑

---

## 第三部分：性能优化方案

### 3.1 渲染优化

**现状问题**：
- 大量 SpriteRenderer 可能影响性能
- 未使用批处理
- 未进行视野剔除

**改进方案**：

**1. Sprite Atlas（图集）**
- 将相关 Sprite 打包成图集
- 减少 DrawCall
- 分类：UI、角色、环境、作物

**2. 视野剔除**
- 只渲染摄像机视野内的对象
- 使用 `OnBecameVisible/OnBecameInvisible`
- 或使用 Culling Group API

**3. 动态批处理**
- 确保 Sprite 使用相同材质
- 避免不必要的材质实例化
- 使用 SpriteRenderer.sharedMaterial

**4. 层级优化**
- 减少 Sorting Layer 数量
- 合理使用 Order in Layer
- 避免频繁切换层级

**预期收益**：
- DrawCall 减少 50%+
- 帧率提升 20-30%
- 支持更大的场景

---

### 3.2 Update 优化

**现状问题**：
- 大量脚本使用 Update()
- 每帧执行不必要的逻辑
- 缺少更新频率控制

**改进方案**：

**1. 事件驱动替代 Update**
- 时间系统：订阅 OnMinuteChanged 而非每帧检查
- UI 刷新：订阅数据变化事件
- 状态机：只在状态切换时更新

**2. 更新频率分级**
- 高频（每帧）：玩家输入、动画同步
- 中频（0.1秒）：AI 决策、路径更新
- 低频（1秒）：资源刷新、天气检查

**3. 协程替代 Update**
- 定时任务使用协程
- 避免空 Update 循环

**4. 对象池化**
- 减少 Awake/Start 调用
- 使用 OnSpawn/OnDespawn

**预期收益**：
- CPU 占用降低 30-40%
- 帧率更稳定
- 电池续航更长（移动平台）

---

### 3.3 内存优化

**现状问题**：
- 资源加载未优化
- 可能存在内存泄漏
- 纹理未压缩

**改进方案**：

**1. 资源管理**
- 使用 Addressables 或 AssetBundle
- 按需加载，及时卸载
- 场景切换时清理资源

**2. 纹理优化**
- 使用合适的压缩格式（ASTC、ETC2）
- 设置合理的 Max Size
- 禁用 Read/Write Enabled

**3. 内存泄漏检测**
- 使用 Memory Profiler
- 检查事件订阅是否正确取消
- 检查静态引用

**4. 对象池**
- 减少 GC 压力
- 控制内存峰值

**预期收益**：
- 内存占用降低 20-30%
- 减少 GC 卡顿
- 支持低端设备

---

## 第四部分：开发流程改进

### 4.1 调试工具完善

**现状问题**：
- 缺少运行时调试工具
- 难以查看游戏状态
- 测试效率低

**改进方案**：

**1. Debug Console**
- 运行时命令行（按 ~ 键打开）
- 支持命令：
  - `time.set 12:00` - 设置时间
  - `time.speed 10` - 时间加速
  - `item.give 1001 10` - 给予物品
  - `player.tp 100 50` - 传送
  - `crop.grow` - 作物立即成熟

**2. Inspector 面板**
- 运行时查看/修改变量
- 查看事件历史
- 查看对象池状态

**3. 性能监控**
- FPS 显示
- 内存使用
- DrawCall 统计
- 对象数量

**4. 快捷键**
- F1：显示/隐藏调试信息
- F2：时间加速
- F3：无敌模式
- F4：无限精力

**预期收益**：
- 测试效率提升 50%+
- 快速定位问题
- 便于演示和录制

---

### 4.2 编辑器工具扩展

**现状问题**：
- 部分重复操作需要手动完成
- 缺少批量处理工具
- 配置效率低

**改进方案**：

**1. 场景编辑工具**
- 批量放置树木/岩石
- 自动生成导航网格
- 一键刷新所有 Order

**2. 数据配置工具**
- 批量创建物品 SO（已有）
- 批量创建作物数据
- 配方编辑器（可视化）

**3. 动画工具**
- 三向动画生成器（已有）
- 动画预览工具
- 帧事件批量添加

**4. 资源管理工具**
- 未使用资源检测
- 重复资源检测
- 资源引用查找

**预期收益**：
- 配置效率提升 3-5倍
- 减少人为错误
- 便于团队协作

---

### 4.3 文档规范

**现状问题**：
- 部分系统缺少文档
- 文档格式不统一
- 更新不及时

**改进方案**：

**1. 文档分类**
- 设计文档（Plan）：系统设计、功能规划
- 技术文档（Solutions）：技术方案、问题解决
- 总结文档（Summary）：阶段总结、经验教训
- API 文档（自动生成）：代码注释 → Markdown

**2. 文档模板**
- 设计文档模板
- 技术方案模板
- 问题报告模板

**3. 文档更新流程**
- 功能开发前：编写设计文档
- 功能完成后：更新技术文档
- 阶段结束后：编写总结文档

**4. 代码注释规范**
- 类注释：功能说明、使用示例
- 方法注释：参数说明、返回值、注意事项
- 复杂逻辑：添加行内注释

**预期收益**：
- 知识沉淀
- 便于交接
- 减少沟通成本

---

## 第五部分：后续开发任务细则

### 5.1 第二阶段任务（第11-20天）

**已规划任务**（来自第二阶段规划）：
- 第11天：锄地系统
- 第12天：种子与种植系统
- 第13天：浇水与作物护理
- 第14天：收获系统与作物完善
- 第15天：农业系统综合测试
- 第16天：主场景规划与地形搭建
- 第17天：资源点分布与场景完善
- 第18天：音效系统集成
- 第19天：生命值系统
- 第20天：基础怪物系统

**新增任务**（基于改进方案）：
- 第11天下午：实现对象池系统（2小时）
- 第12天下午：树木遮挡联动（1小时）
- 第15天：集成事件总线（2小时）
- 第18天：实现 AudioManager（已规划）
- 第20天：实现 Debug Console（2小时）

---

### 5.2 第三阶段任务（第21-30天）

**核心目标**：完善战斗系统、NPC 系统、任务系统

**详细任务**：

**第21天：战斗系统完善**
- 上午：武器数据与动画
- 下午：攻击判定与伤害计算

**第22天：怪物种类扩展**
- 上午：创建 3 种怪物（蝙蝠、哥布林、骷髅）
- 下午：怪物 AI 优化与刷新系统

**第23天：系统整合与优化**
- 上午：解决系统冲突
- 下午：实现存档系统

**第24天：NPC 基础与对话系统**
- 上午：对话系统数据与 UI
- 下午：NPC 脚本与交互逻辑

**第25天：任务系统雏形**
- 上午：任务数据结构与管理系统
- 下午：任务 UI 与测试任务

**第26天：商店系统**
- 上午：商店数据与 UI
- 下午：买卖逻辑与货币系统

**第27天：钓鱼系统（可选）**
- 上午：钓鱼小游戏
- 下午：鱼类数据与奖励

**第28天：烹饪系统（可选）**
- 上午：配方系统扩展
- 下午：烹饪 UI 与食物 Buff

**第29天：综合测试与优化**
- 全天：完整流程测试、Bug 修复、性能优化

**第30天：打包与发布准备**
- 上午：打包配置、资源优化
- 下午：测试打包版本、准备发布材料

---

### 5.3 第四阶段任务（第31-40天）

**核心目标**：内容扩展、平衡性调整、抛光

**详细任务**：

**第31-32天：动物系统**
- 动物数据与 AI
- 动物产出与互动

**第33-34天：节日活动**
- 节日数据与事件
- 特殊活动与奖励

**第35-36天：地牢探险**
- 地牢生成算法
- Boss 战斗与奖励

**第37-38天：婚姻系统**
- NPC 好感度系统
- 约会事件与婚礼

**第39天：平衡性调整**
- 数值调整（价格、时间、难度）
- 玩家反馈收集与修复

**第40天：最终抛光**
- UI 美化
- 音效完善
- 过场动画
- 教程优化

---

## 第六部分：风险与挑战

### 6.1 技术风险

**风险1：性能问题**
- 大量作物/树木导致帧率下降
- 缓解：对象池、视野剔除、分帧更新

**风险2：存档系统复杂**
- 状态过多，难以序列化
- 缓解：分层设计、版本管理、充分测试

**风险3：系统耦合**
- 重构可能影响现有功能
- 缓解：渐进式迁移、充分测试、保留旧代码

---

### 6.2 资源风险

**风险1：美术资源不足**
- 作物、怪物、UI 素材缺失
- 缓解：提前准备资源清单、购买/外包

**风险2：音效资源不足**
- BGM、SFX 缺失
- 缓解：使用免费资源库、后期补充

---

### 6.3 进度风险

**风险1：功能复杂度超预期**
- 某些系统比预期复杂
- 缓解：简化功能、延后非核心功能

**风险2：Bug 修复耗时**
- 测试发现大量 Bug
- 缓解：预留缓冲时间、优先修复核心 Bug

---

## 第七部分：成功标准

### 7.1 第二阶段成功标准

- ✅ 完整的种田循环（耕地→种植→浇水→收获）
- ✅ 至少 10 种作物
- ✅ 完整的世界地图（100x80格）
- ✅ 基础音效系统
- ✅ 玩家血量系统
- ✅ 至少 1 种怪物
- ✅ 性能稳定（30+ FPS）

### 7.2 第三阶段成功标准

- ✅ 完整的战斗系统（3 种武器、3 种怪物）
- ✅ NPC 对话系统
- ✅ 任务系统（至少 5 个任务）
- ✅ 商店系统
- ✅ 存档系统（3 个槽位）
- ✅ 可连续游玩 2 小时无崩溃

### 7.3 第四阶段成功标准

- ✅ 内容丰富（20+ 作物、10+ NPC、20+ 任务）
- ✅ 平衡性良好（难度曲线合理）
- ✅ UI 美观易用
- ✅ 音效完善
- ✅ 性能优秀（60 FPS）
- ✅ 可发布 Demo 版本

---

## 第八部分：总结与展望

### 8.1 项目优势

1. **技术基础扎实**：核心系统设计优秀，代码质量高
2. **文档完善**：设计文档、技术文档齐全
3. **架构清晰**：层次分明，易于扩展
4. **工具链完善**：编辑器工具、生成器齐全

### 8.2 改进重点

1. **事件系统重构**：降低耦合，提高可维护性
2. **性能优化**：对象池、批处理、视野剔除
3. **调试工具**：Debug Console、性能监控
4. **存档系统**：完整的保存/加载功能

### 8.3 未来展望

**短期目标**（3个月）：
- 完成核心玩法
- 发布 Demo 版本
- 收集玩家反馈

**中期目标**（6个月）：
- 内容扩展（更多作物、NPC、任务）
- 平衡性调整
- 发布正式版本

**长期目标**（1年+）：
- DLC 内容（新地图、新系统）
- 多人模式（可选）
- 移动平台移植

---

**文档完成时间**：2024年12月9日  
**下次更新**：第二阶段完成后（预计2024年12月20日）

---

## 附录：快速参考

### A. 关键文件清单

**核心管理器**：
- `TimeManager.cs` - 时间系统
- `SeasonManager.cs` - 季节系统
- `OcclusionManager.cs` - 遮挡管理
- `FarmingManager.cs` - 农田管理（待完善）

**玩家系统**：
- `PlayerMovement.cs` - 移动控制
- `PlayerAnimController.cs` - 动画控制
- `PlayerToolController.cs` - 工具管理
- `LayerAnimSync.cs` - 动画同步

**UI 系统**：
- `PackagePanelTabsUI.cs` - 面板管理
- `InventoryUI.cs` - 背包 UI
- `InventorySlotUI.cs` - 格子 UI

**导航系统**：
- `NavGrid2D.cs` - 导航网格
- `PlayerAutoNavigator.cs` - 自动导航

**环境系统**：
- `TreeController.cs` - 树木控制
- `OcclusionTransparency.cs` - 遮挡透明

### B. 常用命令（未来 Debug Console）

```
// 时间控制
time.set 12:00
time.speed 10
time.pause

// 物品管理
item.give 1001 10
item.clear
item.list

// 玩家状态
player.tp 100 50
player.hp 100
player.stamina 100
player.invincible

// 作物管理
crop.grow
crop.water
crop.harvest

// 系统控制
system.save
system.load
system.fps
```

### C. 性能基准

**目标性能**：
- FPS：60（PC）、30（移动）
- 内存：< 500MB（PC）、< 200MB（移动）
- 加载时间：< 3秒
- 存档大小：< 1MB

**当前性能**（估算）：
- FPS：40-50（未优化）
- 内存：300-400MB
- 加载时间：2-3秒
- 存档大小：未实现

---

**文档结束**
