# 树木成长状态与遮挡透明联动实现方案

## 实现日期
2025-12-10

## 需求背景
树木在不同成长阶段应该有不同的遮挡透明行为：
- **Sapling（树苗）阶段**：体积小，不应参与遮挡透明
- **Small（小树）和 Large（大树）阶段**：体积大，需要遮挡透明
- **Stump（树桩）阶段**：已被砍伐，不应参与遮挡透明

## 实现方案

### 方案选择
采用**方案一**：在 TreeController 中统一管理 OcclusionTransparency 的启用状态

### 核心思路
1. TreeController 在 `Awake()` 中缓存 OcclusionTransparency 组件引用
2. 在 `UpdateColliderState()` 中同步更新 OcclusionTransparency 的启用状态
3. 通过修改 `canBeOccluded` 字段控制组件的启用/禁用

### 实现细节

#### 1. OcclusionTransparency 新增公共方法
```csharp
/// <summary>
/// 动态设置是否可被遮挡（由TreeController等外部控制）
/// </summary>
public void SetCanBeOccluded(bool enabled)
{
    if (canBeOccluded == enabled) return;
    
    bool wasEnabled = canBeOccluded;
    canBeOccluded = enabled;
    
    if (enabled && !wasEnabled)
    {
        // 启用：注册到管理器
        if (OcclusionManager.Instance != null)
        {
            OcclusionManager.Instance.RegisterOccluder(this);
        }
    }
    else if (!enabled && wasEnabled)
    {
        // 禁用：从管理器注销并恢复透明度
        if (OcclusionManager.Instance != null)
        {
            OcclusionManager.Instance.UnregisterOccluder(this);
        }
        SetOccluding(false);
    }
}
```

#### 2. TreeController 缓存组件引用
```csharp
private OcclusionTransparency occlusionTransparency; // 遮挡透明组件引用

void Start()
{
    // ... 其他初始化代码 ...
    
    // ✅ 缓存 OcclusionTransparency 组件引用
    occlusionTransparency = GetComponent<OcclusionTransparency>();
}
```

#### 3. UpdateColliderState() 同步管理遮挡状态
```csharp
private void UpdateColliderState()
{
    // ... Collider 管理代码 ...
    
    // ✅ 树苗阶段：禁用遮挡透明
    if (currentStage == GrowthStage.Sapling)
    {
        if (occlusionTransparency != null)
        {
            occlusionTransparency.SetCanBeOccluded(false);
        }
    }
    // ✅ 树桩阶段：禁用遮挡透明
    else if (currentState == TreeState.Stump)
    {
        if (occlusionTransparency != null)
        {
            occlusionTransparency.SetCanBeOccluded(false);
        }
    }
    // ✅ Small/Large 阶段：启用遮挡透明
    else
    {
        if (occlusionTransparency != null)
        {
            occlusionTransparency.SetCanBeOccluded(true);
        }
    }
}
```

## 逻辑流程

### 树木成长时
1. TreeController 调用 `Grow()` → `UpdateSprite()` → `AlignSpriteBottom()` → `UpdateColliderState()`
2. `UpdateColliderState()` 根据当前阶段调用 `occlusionTransparency.SetCanBeOccluded()`
3. OcclusionTransparency 自动注册/注销到 OcclusionManager

### 树木被砍伐时
1. TreeController 调用 `ChopDown()` → `currentState = TreeState.Stump` → `UpdateSprite()`
2. `UpdateSprite()` → `AlignSpriteBottom()` → `UpdateColliderState()`
3. `UpdateColliderState()` 检测到 Stump 状态，禁用遮挡透明

## 优点
1. **逻辑集中**：所有 Collider 和遮挡透明的管理都在 TreeController 中
2. **易于维护**：与现有的 Collider 管理逻辑一致
3. **不修改核心检测**：OcclusionManager 的核心检测逻辑保持不变
4. **性能更好**：不需要每帧调用 GetComponent

## 修改的文件
1. `Assets/Scripts/Service/Rendering/OcclusionTransparency.cs`
   - 添加 `SetCanBeOccluded(bool)` 公共方法
   
2. `Assets/Scripts/Controller/TreeController.cs`
   - 添加 `occlusionTransparency` 字段
   - 在 `Start()` 中缓存组件引用
   - 在 `UpdateColliderState()` 中同步管理遮挡状态

## 测试要点
1. ✅ 树苗阶段：玩家走到树苗下方，树苗不应变透明
2. ✅ 小树/大树阶段：玩家走到树下，树应该变透明
3. ✅ 树桩阶段：玩家走到树桩下方，树桩不应变透明
4. ✅ 成长过程：树苗成长为小树时，遮挡透明自动启用
5. ✅ 砍伐过程：大树被砍成树桩时，遮挡透明自动禁用

## 相关文档
- [整体项目改进计划以及后续开发任务细则](../Pro/整体项目改进计划以及后续开发任务细则.md)
- [遮挡透明系统设计](../Plan/遮挡透明系统设计.md)（如果存在）
