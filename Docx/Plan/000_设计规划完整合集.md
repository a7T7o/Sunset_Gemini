# 设计规划完整合集

**版本**: v1.0  
**日期**: 2025-12-16  
**状态**: 已合并

---

## 目录

1. [项目总设计](#1-项目总设计)
2. [第二阶段规划](#2-第二阶段规划)
3. [农田系统设计](#3-农田系统设计)
4. [UI系统设计](#4-ui系统设计)
5. [世界物体设计](#5-世界物体设计)
6. [砍树功能设计](#6-砍树功能设计)

---

# 1. 项目总设计

## 1.1 项目概况

**项目名称**: Sunset  
**项目类型**: 2D 农场模拟经营游戏  
**开发引擎**: Unity  
**预计完成周期**: 25个工作日（5周）  
**当前阶段**: 核心框架搭建完成，进入功能实现阶段

## 1.2 当前进度分析

### 已完成模块（30%）

#### 时间系统 (70%完成)
- [x] 基础时间流逝逻辑
- [x] 季节切换系统
- [x] 季节事件触发器
- [ ] UI显示

#### 地图系统 (80%完成)
- [x] Tilemap基础设置
- [x] 所有树木预制体制作
- [x] 树木生成器
- [x] 树木季节变化控制器

#### 角色系统 (90%完成)
- [x] 人物移动控制
- [x] 基础交互系统
- [x] 动画控制器

### 待完成模块（70%）

**优先级P0**（核心玩法）:
- 砍树系统
- 挖矿系统
- 物品与背包系统
- 种植系统
- 精力系统
- 核心UI

**优先级P1**（重要功能）:
- 场景搭建
- 音效系统
- 战斗系统

**优先级P2**（可延后）:
- NPC系统
- 任务系统
- 开场动画
- 剧情系统

## 1.3 详细开发计划

### 第一周：核心交互与物品系统

#### 第1天：斧头动画与砍树系统
- 制作斧头挥砍动画（4帧，0.3-0.4秒）
- 实现砍树逻辑脚本 `TreeInteraction.cs`
- 树木反馈效果（受击晃动、倒下动画）

#### 第2天：岩石预制体与挖矿系统
- 制作岩石预制体（Small/Medium/Large/Iron/Gold）
- 镐子动画制作
- 挖矿逻辑实现 `MiningSystem.cs`

#### 第3天：物品系统数据库搭建
- 创建物品数据结构 `ItemData.cs`
- 设计物品ID分配规则
- 创建物品资产

#### 第4天：掉落物与拾取系统
- 创建掉落物预制体 `DroppedItem.prefab`
- 掉落物行为脚本 `DroppedItemController.cs`
- 拾取系统实现 `ItemPickup.cs`

#### 第5天：背包系统核心
- 背包数据结构 `InventorySystem.cs`
- 物品格子数据类 `InventorySlot.cs`
- 堆叠逻辑实现

### 第二周：UI系统完善

#### 第6天：时间与季节UI
- UI框架搭建
- 时钟UI设计
- 季节UI实现

#### 第7天：精力系统UI与逻辑完善
- 精力系统数据 `StaminaSystem.cs`
- 精力条UI设计
- 精力逻辑完善

#### 第8天：背包UI实现
- 背包UI布局
- 物品格子预制体
- 物品拖拽系统

#### 第9天：工具系统UI与切换
- 工具数据定义 `ToolData.cs`
- 工具管理系统 `ToolManager.cs`
- 工具UI显示

#### 第10天：综合测试与修复
- 系统集成测试
- Bug修复
- 平衡性调整

### 第三周：农业系统完整实现

#### 第11天：土地耕作系统
- 锄头动画制作
- 耕地Tilemap设置
- 土地状态系统

#### 第12天：种植系统
- 种子数据结构 `SeedData.cs`
- 作物数据结构 `CropData.cs`
- 种植逻辑实现

#### 第13天：浇水与作物护理
- 浇水壶动画
- 浇水系统实现
- 土地湿度系统

#### 第14天：收获系统与作物完善
- 作物成熟判定
- 收获动画
- 可重复收获系统

#### 第15天：农业系统综合测试
- 完整流程测试
- 平衡性调整
- UI优化

### 第四周：场景搭建与战斗系统

#### 第16天：主场景规划与地形搭建
- 场景规划设计
- Tilemap层级设置
- 地形绘制

#### 第17天：资源点分布与场景完善
- 树木分布
- 岩石/矿石分布
- 功能性建筑

#### 第18天：音效系统集成
- 音效资源整理
- 音效管理系统 `AudioManager.cs`
- 动作音效集成

#### 第19天：生命值系统
- 生命值数据系统 `HealthSystem.cs`
- 玩家血量UI
- 受伤反馈效果

#### 第20天：基础怪物系统
- 怪物数据结构 `EnemyData.cs`
- 基础怪物预制体
- 怪物AI脚本 `EnemyAI.cs`

### 第五周：战斗完善与系统整合

#### 第21天：战斗系统与武器
- 武器数据 `WeaponData.cs`
- 战斗系统脚本 `CombatSystem.cs`
- 攻击判定实现

#### 第22天：怪物种类扩展与AI优化
- 创建新怪物类型
- AI优化
- 怪物刷新系统

#### 第23天：系统整合与优化
- 系统冲突解决
- 存档系统实现
- 性能优化

#### 第24天：NPC基础与对话系统
- 对话系统数据 `DialogueData.cs`
- 对话UI设计
- NPC基础脚本

#### 第25天：任务系统雏形与最终测试
- 任务数据结构 `QuestData.cs`
- 任务管理系统
- 全游戏最终测试

## 1.4 技术实现要点

### 代码架构
```
Assets/Scripts/
├── Core/          # 核心管理器
├── Player/        # 玩家控制、动画
├── Items/         # 物品、背包系统
├── Farming/       # 农业相关
├── Combat/        # 战斗、武器
├── Enemies/       # 敌人AI
├── UI/            # 所有UI脚本
├── Environment/   # 树木、岩石等
├── NPC/           # NPC和对话
└── Utilities/     # 工具类
```

### 设计模式应用
- **单例模式**: GameManager, TimeManager, AudioManager, SaveSystem
- **对象池模式**: 怪物、掉落物、粒子效果
- **观察者模式**: 事件系统
- **状态机模式**: 敌人AI、玩家动画控制
- **工厂模式**: 物品生成、怪物生成

---

# 2. 第二阶段规划

## 2.1 阶段目标

### 总体目标
从第一阶段的**框架搭建**转向**玩法实现**：
1. 种植循环：锄地 → 种植 → 浇水 → 生长 → 收获
2. 场景完善：完整的世界地图与资源分布
3. 反馈系统：音效、粒子效果、UI反馈
4. 战斗系统：基础生命值与怪物AI

### 关键里程碑
- **里程碑1**（第15天）：完整的种田循环可玩
- **里程碑2**（第17天）：完整的场景与资源分布
- **里程碑3**（第20天）：基础战斗系统运行

## 2.2 周计划概览

### 第三周：种植系统（第11-15天）
- **第11天**：锄地系统
- **第12天**：种子与种植系统
- **第13天**：浇水与作物护理
- **第14天**：收获系统
- **第15天**：农业系统综合测试

### 第四周：场景与战斗（第16-20天）
- **第16天**：主场景规划与地形搭建
- **第17天**：资源点分布与场景完善
- **第18天**：音效系统集成
- **第19天**：生命值系统
- **第20天**：基础怪物系统

## 2.3 成功标准

1. ✅ 玩家可以完整体验：耕地→种植→浇水→生长→收获
2. ✅ 至少10种作物，覆盖春夏秋三个季节
3. ✅ 完整的世界地图（100x80格），包含6个主要区域
4. ✅ 40-60棵树木，30-50个岩石/矿石
5. ✅ 基础音效系统运行
6. ✅ 玩家有血量系统
7. ✅ 至少1种怪物，具备基础AI
8. ✅ 性能稳定（30+ FPS）

---

# 3. 农田系统设计

## 3.1 系统概述

### 核心玩法循环
```
锄地（Hoe）→ 种植（Plant）→ 浇水（Water）→ 等待生长（Growth）→ 收获（Harvest）
                ↑______________________________________________|（可重复收获作物）
```

### 关键特性
- ✅ 基于Tilemap的动态土地状态管理
- ✅ 多生长阶段的作物系统
- ✅ 浇水与湿度管理
- ✅ 季节限制与天气影响
- ✅ 作物品质系统
- ✅ 可重复收获作物支持

## 3.2 技术架构

### Tilemap层级设计
```
Grid (父对象)
├── Ground_Base (地面基础层, Order: 0)
├── Ground_Detail (地面装饰层, Order: 1)
├── Farmland (耕地层, Order: 2) ← 核心农田层
└── Objects (放置作物GameObject的层, Order: 3)
```

### 数据结构设计

#### FarmTileData
```csharp
public class FarmTileData
{
    public Vector3Int position;           // 格子坐标
    public bool isTilled;                 // 是否已耕作
    public bool isWatered;                // 是否已浇水
    public float lastWateredTime;         // 上次浇水时间
    public CropInstance crop;             // 当前种植的作物实例
}
```

#### CropInstance
```csharp
public class CropInstance
{
    public SeedData seedData;             // 种子数据
    public GameObject cropObject;         // 场景中的作物GameObject
    public int currentStage;              // 当前生长阶段
    public float plantedTime;             // 种植时间
    public float nextGrowthTime;          // 下次生长时间
    public int harvestCount;              // 已收获次数
    public Quality quality;               // 作物品质
}
```

## 3.3 核心系统设计

### FarmingManager
```csharp
// 核心方法
public bool TillSoil(Vector3Int position)
public bool CanPlant(Vector3Int position)
public bool PlantSeed(Vector3Int position, SeedData seed)
public bool WaterTile(Vector3Int position)
public CropData HarvestCrop(Vector3Int position)
public void ClearCrop(Vector3Int position)
```

### CropGrowthSystem
```
每天检查：
  如果已浇水：
    - 生长进度 +1
    - 检查是否进入下一阶段
    - 更新作物外观
  如果未浇水：
    - 连续未浇水天数 +1
    - 达到2天：生长停滞
    - 达到3天：作物枯萎
```

### WaterEvaporationSystem
- 监听时间系统的OnDayChanged事件
- 每天检查所有已浇水的土地
- 24小时后土地变干

## 3.4 资源准备方案

### 所需Tile资源
- `Farmland_Dry.png` (已耕作-干燥)
- `Farmland_Wet.png` (已耕作-湿润)

### 作物Sprite准备
每种作物需要4-5个生长阶段的Sprite：
```
Stage0: Seed        (种子)
Stage1: Sprout      (幼苗)
Stage2: Small       (小植株)
Stage3: Growing     (生长中)
Stage4: Mature      (成熟)
```

## 3.5 实施步骤

### 阶段1：基础框架
1. 创建FarmingManager.cs
2. 创建CropGrowthSystem.cs
3. 设置Farmland Tilemap层
4. 准备基础Tile

### 阶段2：锄地系统
1. 创建锄头动画
2. 实现FarmingManager.TillSoil()
3. 添加锄地音效和粒子效果

### 阶段3：种植系统
1. 创建Crop.prefab基础模板
2. 实现FarmingManager.PlantSeed()
3. 创建测试作物的SeedData

### 阶段4：浇水系统
1. 创建浇水壶动画
2. 实现FarmingManager.WaterTile()
3. 实现WaterEvaporationSystem

### 阶段5：生长系统
1. 实现CropGrowthSystem
2. 连接TimeManager的OnDayChanged事件
3. 实现枯萎系统

### 阶段6：收获系统
1. 实现FarmingManager.HarvestCrop()
2. 实现可重复收获逻辑
3. 实现作物品质判定

## 3.6 数据配置示例

### SeedData配置（番茄种子）
```
Item ID: 1001
Item Name: 番茄种子
生长天数: 9天
适合季节: Summer
收获作物ID: 1101
收获数量: 1-3个
可重复收获: true
重复收获间隔: 3天
```

---

# 4. UI系统设计

## 4.1 规范与基本约定

- 画布：`Canvas (Screen Space - Overlay)`，参考分辨率 1920x1080
- `Canvas Scaler` 设为 `Scale With Screen Size`，`Match = 0.5`
- 美术：沿用像素 UI 风格；保持 4/8 像素栅格对齐
- 命名：统一英文路径与 PascalCase 组件名

## 4.2 预制体与目录

```
Assets/Prefabs/UI/
├── HUD/
│   ├── TimeMoneyHUD.prefab
│   └── StatsHUD.prefab
├── Toolbar/
│   └── Toolbar.prefab
├── Package/
│   ├── PackagePanel.prefab
│   ├── InventorySlotUI.prefab
│   └── RecipeItemUI.prefab
└── Common/
    ├── Tooltip.prefab
    └── DragGhost.prefab
```

## 4.3 背包/格子/拖拽

### InventorySlotUI 组件结构
- 子节点：`BG(Image)`、`Icon(Image)`、`Amount(Text)`、`QualityStars(Image[])`、`Highlight(Image)`、`Button`
- 必要接口：
  - `SetEmpty()`、`SetStack(itemId, quality, amount)`、`Refresh()`
  - `Bind(index, InventoryService service)`

### 拖拽与垃圾桶
- 拖拽开始：生成 `DragGhost`
- 放下：
  - 放在另一个 Slot：调用 `InventoryService.SwapOrMerge(from, to)`
  - 放在 ToolBar：调用 `HotbarService.Bind(hotbarIndex, inventoryIndex)`
  - 放在垃圾桶：弹出确认

## 4.4 工具栏（Toolbar）

- 结构：8 格 `ToolbarSlotUI`
- 交互：
  - 数字键 1-8 切换选中槽
  - 拖动背包物品到某格建立绑定

## 4.5 HUD

### TimeMoneyHUD
- 文本/图标显示当前时间、当天/季节、金币数量
- 订阅 `TimeService.TimeTick` 与 `CurrencyService.GoldChanged`

### StatsHUD
- 两条 `Image.fillAmount` 展示 HP 与 Stamina
- 订阅 `StatsService.StatsChanged`
- 低于 20% 闪烁/变色

## 4.6 详情/Tooltip

- 内容：名称、描述、品质星、售价、使用/装备类型
- 出现时机：指针进入 Slot/Toolbar；延时 0.15s
- 位置：跟随鼠标，屏幕边界内偏移

## 4.7 与动画/装备联动

### 装备逻辑
1. Hotbar 选择/点击使用工具 → `EquipmentService.Equip(itemId, quality)`
2. 查询 `ItemDatabase` 得到 `ToolData`
3. `animKeyId = toolData.GetAnimationKeyId()`
4. 写入 Animator：`ToolItemId = animKeyId`、`ToolQuality = quality`
5. `LayerAnimSync` 负责状态名组装、`HasState` 检查与品质回退

---

# 5. 世界物体设计

## 5.1 设计目标

- 将 ScriptableObject 物品数据与场景世界中的实体建立稳定的运行时映射
- 与背包/ToolBar/UI、玩家动作/动画、保存/加载深度联动
- 统一交互协议

## 5.2 分层与契约

### 数据层（SO）
- `ItemData`（icon、stack、sellPrice、worldPrefab）
- `ToolData`（toolType、energyCost、GetAnimationKeyId）
- `WeaponData`

### 实体层（World）
- `WorldItemPickup`：场景掉落/拾取物
- `ResourceNode`：树/矿石等可采集物
- `InteractableXxx`：其他可交互体

### 服务层（Runtime Services）
- `InventoryService`、`EquipmentService`、`HotbarSelectionService`
- `DropService`、`WorldSpawnService`
- `SaveService`

## 5.3 世界物体类型（统一接口）

### IInteractable
```csharp
bool CanInteract(PlayerContext ctx)
float GetStopRadius()
void Interact(PlayerContext ctx)
Vector3 GetInteractPoint()
```

### IPickup
```csharp
ItemStack GetStack()
void SetStack(ItemStack)
void OnPicked(PlayerContext ctx)
```

### IResourceNode
```csharp
bool CanHit(ToolType type)
void Hit(PlayerContext ctx, ToolType type, int power)
bool IsDepleted()
IEnumerable<ItemStack> GetDrops()
```

## 5.4 WorldItemPickup（拾取物）

- 字段：`itemId, quality, amount`
- 生成：
  - 关卡预置：直接在场景放置
  - 运行时掉落：由 `DropService.Spawn(worldPos, ItemStack)`
- 交互：
  - 与玩家碰撞/点击触发 `TryPickup()`
  - `int rem = InventoryService.AddItem(itemId, quality, amount)`

## 5.5 ResourceNode（资源点）

- 字段：生命/阶段、可用工具类型、`DropTable`
- 命中流程：
  1. 玩家左键 → `GameInputManager` 根据 Hotbar 选中装备工具
  2. 动画事件触发 `node.Hit(ctx, toolType, power)`
  3. 生命归零 → `DropService.Spawn` 多个 `WorldItemPickup`

## 5.6 保存/加载

### SaveData
```csharp
inventory（36格）
hotbarSelected（索引）
equips(6)
time（年/季/日/时/分）
gold
stats（hp/stamina）
worldPickups: [ {scene,itemId,quality,amount,position} ... ]
resourceNodes: [ {scene,uniqueId,hp,stage,respawn} ... ]
```

---

# 6. 砍树功能设计

## 6.1 目标与原则

- 零延迟命中手感：与玩家动画严格同步
- 低耦合、清职责：采集系统与动作系统解耦
- 可扩展：同一套机制适配"砍树"和"挖矿"
- 数据驱动：树配置用 ScriptableObject 管理

## 6.2 命中触发方案

### 方案 A：动画事件驱动（推荐）
- 在每个工具攻击剪辑的命中帧添加 AnimationEvent
- 事件统一调用 `PlayerToolHitEmitter.OnToolStrike()`

### 方案 B：帧锁无事件（兜底）
- 由 `PlayerToolHitEmitter` 读取玩家当前动画状态
- 当进入命中窗（如帧 3～4）时触发一次

## 6.3 扇形命中体

- 夹角：默认 60°（±30°）
- 半径：默认取"斧头在 frame_4 时，斧头 sprite 最远点到人物中心"的距离
- 物理实现：用 `OverlapCircle` 先圈定半径，再对命中集合做角度过滤

## 6.4 推荐总体架构

### PlayerToolHitEmitter（玩家侧）
- 职责：接收命中时刻，计算命中区域与方向，广播命中事件

### IResourceNode（统一接口）
```csharp
bool CanAccept(ToolHitContext ctx)
void ApplyHit(ToolHitContext ctx)
```

### TreeController（实现 IResourceNode）
- 职责：管理树的生命值/阶段切换/动画与掉落

### TreeConfig（ScriptableObject）
```csharp
int treeId
string displayName
int maxHP
float wobbleDuration
int[] stageThresholds
AllowedTools
DropTable
AudioClips SfxHit/SfxFall
GameObject stumpPrefab
```

## 6.5 关键流程

1. 玩家挥砍动画播放
2. 命中帧到达：
   - A：剪辑事件调用 `OnToolStrike()`
   - B：帧窗触发
3. `PlayerToolHitEmitter`：
   - 读取工具参数
   - 计算扇形命中体
   - 逐个 `IResourceNode` 执行 `CanAccept` → `ApplyHit`
4. `TreeController.ApplyHit(ctx)`：
   - 检查工具类型/品质
   - 扣减 HP，播放受击抖动
   - HP ≤ 0：播放倒下逻辑，生成掉落

## 6.6 实施清单

1. 新建接口与数据：`IResourceNode`、`ToolHitContext`、`TreeConfig`
2. 实现 `TreeController`（IResourceNode），挂到树 Prefab
3. 新建 `PlayerToolHitEmitter`，挂到玩家
4. 临时采用方案 B（帧窗）立即可用
5. 在地图放置树，设置 Layer=Resource
6. 验收：命中时只对前方树造成伤害

---

# 附录：相关文档索引

| 文档 | 路径 | 内容 |
|------|------|------|
| 农田系统完整文档 | `Docx/农田/农田系统完整文档.md` | 农田系统详细设计 |
| UI系统完整文档 | `Docx/界面UI/UI系统完整文档.md` | UI系统详细设计 |
| 项目全局文档 | `Docx/全局/项目全局文档.md` | 项目整体架构 |
| 第二阶段任务清单 | `Docx/000_任务列表/第二阶段正式冲刺.md` | 详细任务分解 |

---

**文档合并完成时间**: 2025-12-16  
**原始文档数量**: 10个  
**合并后状态**: 按主题分类整理
