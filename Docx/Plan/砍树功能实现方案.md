# 砍树功能实现方案

本文给出可落地的砍树功能设计，兼顾与现有“Mode A++ 帧锁同步、三向动画融合生成器、工具控制器与参数体系”的对接；在保证低耦合、可扩展、易测试的前提下，优先选择最简洁、最稳定的实现路径。文末附迭代计划与测试用例。

---

## 1. 目标与原则

- 零延迟命中手感：与玩家动画严格同步（沿用 Mode A++ 8 帧固定结构）。
- 低耦合、清职责：采集系统（树）与动作系统（玩家/工具）解耦，通过清晰的事件/接口对接。
- 可扩展：同一套机制适配“砍树”和未来“挖矿”（石头控制器届时接入同样接口）。
- 数据驱动：树配置（血量、阶段、掉落、受击规则）用 ScriptableObject 管理。
- 最小出错面：少状态交叉、少隐式依赖、避免复杂条件交织。

---

## 2. 现有上下文与约束（关键对接点）

- 动画生成与控制器
  - Clips 命名：`{动作}_{方向}_Clip_{itemId}_{quality}`，固定 8 帧。
  - Controller 参数：`State`、`Direction`、`ToolItemId`、`ToolQuality`。
  - 仅 Any State → 目标状态，无状态间互转；与“挥砍中不换材质”一致。
- 运行时动画同步
  - `LayerAnimSync` 基于 Mode A++ 帧锁，按玩家帧精确驱动工具动画，已支持 `ToolItemId` + `ToolQuality` 质量回退。
- 工具装备
  - `PlayerToolController.EquipTool(toolType, toolQuality)` 设置工具 AnimatorController，并写入 `ToolItemId`、`ToolQuality`。

---

## 3. 砍树“命中触发”方案对比（统一事件，A 为主、B 兜底）

- 方案 A：动画事件驱动（推荐）
  - 在每个工具攻击剪辑的命中帧添加 AnimationEvent（例如第 4 帧或基于“最后一帧”参数的 60% 处），事件统一调用 `PlayerToolHitEmitter.OnToolStrike()`。
  - 优点：
    - 时序最明确，维护成本低，命中信号来源唯一。
    - 与 8 帧结构强绑定，手感稳定，误触发概率低。
  - 缺点：
    - 需要批量在剪辑中注入事件（可由生成器后续一键注入，避免手工）。

- 方案 B：帧锁无事件（基于时间窗）
  - 由 `PlayerToolHitEmitter` 读取玩家当前动画状态与“归一化时间/帧下标”，当进入命中窗（如帧 3～4）时触发一次 `OnToolStrike()`。
  - 优点：
    - 无需维护剪辑事件，统一逻辑在代码侧可热修。
  - 缺点：
    - 需要防抖（避免多个 Update 触发），状态切换与 Blend 时可能出现边界情况。

- 方案 C：短时 Hitbox 物体
  - 攻击时实例化（或启用）一个短时触发器 Hitbox（随方向摆放），由 `OnTriggerEnter2D` 判定命中树。
  - 优点：
    - 形状可视化，易调试，适配多道具。
  - 缺点：
    - 仍需与时序对齐（通常还是依赖 A/B），多 Collider/触发管理更复杂。

结论：首选 A（动画事件），以最少状态与最高确定性获得最佳手感；保留 B 作为兜底逻辑（无事件时仍能触发一次）。所有命中最终统一走“扇形命中体 + IResourceNode”流程。

### 3.1 扇形命中体（60°，frame_4 半径，默认策略）

- 命中体：以玩家当前朝向为中心线的扇形。
  - 夹角：默认 60°（±30°）。
  - 半径：默认取“斧头在 frame_4 时，斧头 sprite 最远点到人物中心”的距离。
    - 计算来源：读取 frame_4 使用的 sprite 的 `rect(像素) / pixelsPerUnit` 与 `pivot`；以玩家中心点（建议使用玩家主 SpriteRenderer 的 `bounds.center` 或专用 `playerCenter` 空物体）为参考，估算 reach。
    - 简化稳健公式（默认实现）：`reach = distance(playerCenter, toolAttach) + max(sprite.bounds.extents)`（再乘以缩放）；其中 `toolAttach` 为工具挂点。
    - 可配置项：允许在工具配置中覆盖默认 reach（用于精修或异常贴图）。
- 物理实现：用 `OverlapCircle`/`OverlapCircleNonAlloc` 先圈定半径，再对命中集合做角度过滤（与前向夹角 ≤ 30°）。
- 结果：得到扇形内的候选目标（树/怪/其他实现了 `IResourceNode` 的对象）。

---

## 4. 推荐总体架构

- 新增组件：`PlayerToolHitEmitter`（玩家侧）
  - 职责：接收命中时刻（事件或帧窗），计算命中区域与方向，广播命中事件并执行物理查询对资源节点造成伤害。
  - 依赖：仅依赖玩家的 Transform/朝向、工具 Animator 参数（读取 `ToolItemId`、`ToolQuality`、`Direction`、`State`）。不依赖树的内部实现。

- 统一接口：`IResourceNode`（资源节点通用接口）
  - `bool CanAccept(ToolHitContext ctx)`
  - `void ApplyHit(ToolHitContext ctx)`
  - 作用：屏蔽“树 / 石头 / 其他矿藏”的差异，玩家只面向接口编程。

### 4.1 统一 ToolStrike 事件与广播协议（新增）

- 事件总线：`ToolEvents.ToolStrike`（C# 事件/MessageBus 皆可），载荷：`ToolStrikeEventArgs`。
- 触发方：`PlayerToolHitEmitter` 在计算出“扇形命中结果”后广播；确保只在命中时刻触发一次。
- 订阅方：`TreeController`、`EnemyController`、统计/任务系统、音效/VFX 系统等。
- 载荷建议：
  - `GameObject attacker`
  - `int toolItemId, toolQuality, actionState`（Slice=6）
  - `int frameIndex`（默认 4）与 `float normalizedTime`
  - `Vector2 origin`（玩家中心）与 `Vector2 forward`
  - `float wedgeAngleDeg=60` 与 `float reach`
  - `IReadOnlyList<Collider2D> candidates`（已在扇形内的命中集合，供订阅者二次校验/使用）
  - `Bounds? spriteBoundsAtHit`（可选，调试）
- 处理约定：
  - 游戏性判定由 `PlayerToolHitEmitter` 负责（先做扇形查询与角度过滤，再广播）。
  - 订阅方可只对自身相关事件响应（例如比较 `candidates` 是否包含自身 Collider）。
  - 也保留直接接口调用路径（`IResourceNode.ApplyHit`），两者可并存（事件用于旁路系统如任务/音效；直接调用用于核心伤害）。

- 树控制器：`TreeController`（实现 `IResourceNode`）
  - 职责：管理树的生命值/阶段切换/动画与掉落；与保存系统对接（可后续接）。
  - 数据：`TreeConfig`（SO）驱动，包含生命、阶段、受击规则、掉落、音效/VFX 等。

- 数据对象：`TreeConfig : ScriptableObject`
  - 字段建议：
    - `int treeId`
    - `string displayName`
    - `int maxHP`
    - `float wobbleDuration`
    - `int[] stageThresholds`（如三阶段：绿叶→稀疏→树桩）
    - `AllowedTools`（允许的 `ActionType` 与最低 `ToolQuality`，以及伤害系数）
    - `DropTable`（掉落物与数量范围）
    - `AudioClips SfxHit/SfxFall`
    - `GameObject stumpPrefab`（被砍倒后的占位物体）

- 事件/上下文：`struct ToolHitContext`
  - `ActionType actionType`（Slice=6）
  - `int toolItemId`
  - `int toolQuality`
  - `Vector2 hitPoint` / `Vector2 hitDir`
  - `GameObject attacker`（玩家）
  - `float baseDamage`（可由工具/品质估算）

---

## 5. 关键流程（推荐实现：A 框架 + B 兜底）

1) 玩家挥砍动画播放（已由 Controller 与 LayerAnimSync 保证零延迟）。
2) 命中帧到达：
   - A：剪辑事件 `OnToolStrike()` 调用 `PlayerToolHitEmitter.OnToolStrike()`。
   - B：若无事件，`PlayerToolHitEmitter` 在 Update 内依据帧窗（如 3～4 帧）触发一次。
3) `PlayerToolHitEmitter`：
   - 读取 `ToolItemId`、`ToolQuality`、`Direction`、`State`；校验 `State == Slice` 才能命中树。
   - 计算“扇形命中体”（60°，半径为 frame_4 reach）：
     - 先用 `Physics2D.OverlapCircle(NonAlloc)` 以半径 `reach` 圈定候选；
     - 逐一以`Vector2.Angle(forward, (targetPos-origin)) <= 30°`过滤角度；
     - 得到 `candidates` 集合。
   - 逐个 `IResourceNode` 执行 `CanAccept` → `ApplyHit`；并广播 `ToolEvents.ToolStrike(args)`（包含 `candidates`）。
4) `TreeController.ApplyHit(ctx)`：
   - 检查工具类型/品质是否满足。
   - 依据配置计算伤害（品质系数、树韧性系数、临界最小伤害）。
   - 扣减 HP，播放受击抖动（wobble）与音效，生成受击 VFX。
   - 阶段切换：当 HP 穿越阈值时，替换贴图/子节点表现。
   - HP ≤ 0：播放倒下逻辑，生成掉落，替换为树桩 `stumpPrefab`（带交互/阻挡体积）。

---

## 6. 组件设计（接口与伪码）

### 6.1 PlayerToolHitEmitter（玩家命中发射器）

职责：把“动画命中时刻”转化为“对前方资源的命中计算”。

伪码（已切换为“扇形命中体”实现）：
```csharp
class PlayerToolHitEmitter : MonoBehaviour {
    public LayerMask resourceMask;
    public float wedgeAngleDeg = 60f;
    public int hitFrameIndex = 4; // 默认 frame_4
    public float reachPadding = 0.05f; // 误差补偿

    Animator toolAnimator; Transform player; bool frameWindowConsumed;

    // A：动画事件入口
    public void OnToolStrike() { TryHit(); }

    // B：无事件兜底（命中窗检测）
    void Update() {
        if (InHitWindow() && !frameWindowConsumed) { frameWindowConsumed = true; TryHit(); }
        if (!InHitWindow()) frameWindowConsumed = false;
    }

    void TryHit() {
        var ctx = BuildContext();
        var origin = GetPlayerCenter();
        var forward = GetFacingDir();
        float reach = ResolveReachAtFrame(hitFrameIndex) + reachPadding;
        var all = Physics2D.OverlapCircleAll(origin, reach, resourceMask);
        var candidates = new List<Collider2D>(all.Length);
        foreach (var col in all) {
            var dir = ((Vector2)col.bounds.ClosestPoint(origin) - origin).normalized;
            if (Vector2.Angle(forward, dir) <= wedgeAngleDeg * 0.5f) candidates.Add(col);
        }
        foreach (var col in candidates) if (col.TryGetComponent<IResourceNode>(out var node)) if (node.CanAccept(ctx)) node.ApplyHit(ctx);

        // 广播统一事件
        ToolEvents.ToolStrike?.Invoke(new ToolStrikeEventArgs{ attacker=gameObject, toolItemId=ctx.toolItemId, toolQuality=ctx.toolQuality, actionState=ctx.actionState, frameIndex=hitFrameIndex, origin=origin, forward=forward, wedgeAngleDeg=wedgeAngleDeg, reach=reach, candidates=candidates });
    }
}
```

要点：
- `BuildContext()` 从 toolAnimator 取 `ToolItemId/ToolQuality/Direction/State`；`baseDamage` 可按工具品质映射。
- `ResolveReachAtFrame(4)`：
  - 从当前剪辑曲线取第 4 帧对应的 Sprite；用 `sprite.rect/pixelsPerUnit` 与 `pivot` 估算局部几何尺寸；
  - 结合 `toolAttach` 的世界位置与 `forward`，近似取 `reach = |toolAttach - origin| + max(sprite.bounds.extents)`；
  - 若取样失败，退化为 `defaultReach`（可配）并记录日志一次。
- 命中窗：8 帧中如第 3～4 帧（由项目手感再微调，或读取剪辑事件时间）。

### 6.1.1 事件与载荷（建议）

```csharp
public static class ToolEvents {
    public static Action<ToolStrikeEventArgs> ToolStrike; // 全局统一广播
}

public class ToolStrikeEventArgs {
    public GameObject attacker; public int toolItemId, toolQuality, actionState, frameIndex;
    public Vector2 origin, forward; public float wedgeAngleDeg, reach; 
    public IReadOnlyList<Collider2D> candidates; // 扇形内候选
}
```

### 6.2 IResourceNode（统一资源接口）
```csharp
public interface IResourceNode {
    bool CanAccept(ToolHitContext ctx);
    void ApplyHit(ToolHitContext ctx);
}

public struct ToolHitContext {
    public int toolItemId; public int toolQuality; public int actionState; // Slice=6
    public Vector2 hitPoint; public Vector2 hitDir; public GameObject attacker; public float baseDamage;
}
```

### 6.3 TreeController（树控制器，实现 IResourceNode）

职责：管理生命、受击表现、阶段/倒下/掉落。与保存系统/任务系统松耦合（通过事件上报）。

伪码：
```csharp
class TreeController : MonoBehaviour, IResourceNode {
    public TreeConfig config; // 数据驱动
    int hp;
    Animator anim; SpriteRenderer sr;

    void Awake(){ hp = config.maxHP; anim = GetComponent<Animator>(); sr = GetComponent<SpriteRenderer>(); }

    public bool CanAccept(ToolHitContext ctx){
        // 只接受 Slice，且品质达到要求
        return ctx.actionState == (int)ActionType.Slice && config.Allow(ctx.toolQuality);
    }

    public void ApplyHit(ToolHitContext ctx){
        int dmg = config.CalcDamage(ctx.toolQuality, ctx.toolItemId, ctx.baseDamage);
        hp = Mathf.Max(0, hp - dmg);
        PlayHitFX();
        UpdateStageByHP();
        if (hp <= 0) Fell();
        RaiseEvent_OnHit(ctx); // 可选：广播统计/任务/音效系统
    }

    void Fell(){
        PlayFallAnimOrSwapToStump();
        SpawnDrops(config.DropTable);
        DisableTreeCollision();
        RaiseEvent_OnFell(); // 保存/任务系统监听
    }
}
```

要点：
- 阶段切换可由 `stageThresholds` 控制（贴图替换或 Animator 切 State）。
- 倒下可选择：
  - A：树 Animator 播放“倒下”剪辑；
  - B：直接替换为 `stumpPrefab`（更易维护）。

---

## 7. 数据结构（TreeConfig 建议）

```csharp
[CreateAssetMenu(menuName="Configs/TreeConfig")]
class TreeConfig : ScriptableObject {
    public int treeId; public string displayName; public int maxHP = 30;
    public int[] stageThresholds; // 例：{20, 10} 表示 >20 阶段1，>10 阶段2，<=10 阶段3（临近倒下）
    public int minQualityRequired = 0; // 最低品质
    public float qualityDamageFactor = 1.0f; // 伤害随品质的放大
    public AnimationCurve toughnessByStage; // 不同阶段抗性
    public DropEntry[] drops;
    public GameObject stumpPrefab;
    public AudioClip sfxHit, sfxFall;

    public bool Allow(int q) => q >= minQualityRequired;
    public int CalcDamage(int q, int itemId, float baseDamage){
        float factor = qualityDamageFactor * (1 + 0.1f * Mathf.Max(0, q - minQualityRequired));
        return Mathf.Max(1, Mathf.RoundToInt(baseDamage * factor));
    }
}
```

> 注：数值公式保持简单，后续可按手感再迭代。

---

## 8. 层/碰撞/性能

- 统一把树等资源放在 Layer：`Resource`。
- 命中查询采用 `Physics2D.OverlapBox(NonAlloc)`，只在命中时刻执行一次，性能开销极低。
- 树使用普通 Collider（非触发），由玩家射线/Overlap 查询命中；
- 若树体积较大，可给“可砍部位”单独子 Collider，并挂 `TreeController` 在根节点。

---

## 9. 动画与音视效

- 工具动画：已稳定（Any State 直达、8 帧、品质回退）。
- 命中事件（统一）：
  - 在“三向动画融合生成器”中新增“为斧头注入命中事件（默认开启）”：
    - 注入方式：对生成的斧头相关剪辑，在 frame_4 的时间点插入 `OnToolStrike`（方法名固定）。
    - 时间点计算：若采用 8 帧固定分布，取 `t4 = holdStartTime * (4/7)`；若有自定义 `totalFrames/lastFrame`，则 `t4 = (lastFrame/60) * (4/7)`。
    - 去重规则：若剪辑已存在同名事件，则跳过或提示用户（避免重复）。
    - 适用范围：ActionType=Slice 且工具标记为“斧头”的 item；UI 提供开关，默认开启。
- 树受击：
  - `TreeController` 播放轻微抖动/颜色闪烁（或调用 `anim.SetTrigger("Hit")`）。
  - 倒下：选择 Animator 播放或直接换 `stumpPrefab`。

---

## 10. 与其他系统的耦合约束

- 与玩家/工具：仅读取工具 Animator 的参数；不反向依赖 `LayerAnimSync` 的内部实现。
- 与掉落/背包：树只负责调用 `Dropper.Spawn(drops)`；不关心背包接收细节。
- 与保存：`TreeController` 抛出 `OnTreeStateChanged` 事件，保存系统订阅并记录 `treeId`、剩余 HP/阶段与是否已砍倒。
- 与任务：同样通过事件聚合（EventBus）监听。

---

## 11. 实施清单（最小增量）

1) 新建接口与数据：`IResourceNode`、`ToolHitContext`、`TreeConfig`。
2) 实现 `TreeController`（IResourceNode），挂到树 Prefab。
3) 新建 `PlayerToolHitEmitter`，挂到玩家（读取工具 Animator、朝向；提供 OnToolStrike()）。
4) 临时采用方案 B（帧窗 3～4）立即可用；随后在生成器中加“事件注入”切到方案 A。
5) 在地图放置树，设置 Layer=Resource，配置 Collider 与 TreeConfig。
6) 验收：命中时只对前方树造成伤害；倒下后掉落与替换树桩；多品质/多方向正常。

---

## 12. 测试用例（关键）

- 命中时序
  - 动画第 3～4 帧触发一次；第 2、5 帧不触发；快速连击不过量触发。
- 方向/Flip
  - 左右翻转、上下方向的 Overlap 区域正确；只命中前方资源。
- 工具条件
  - 低于最低品质不掉血；品质提升伤害按比例提升。
- 多实体
  - 多棵树近距离排列时，仅命中 Overlap 内的；同帧多目标可同时受伤（可选）。
- 阶段与倒下
  - HP 阶段切换表现正确；HP<=0 倒下并生成掉落与树桩；树桩不可再被砍。
- 性能
  - 连续挥砍检测无 GC 峰值，Profiler 中 Overlap 次数与帧事件次数一致。

---

## 13. 对“挖矿”的前置适配

- 石头控制器未就绪时，仅需实现 `RockController : MonoBehaviour, IResourceNode` 同接口；
- 其余逻辑（命中、Overlap、工具条件、掉落）可直接复用当前方案；
- 待石头 Animator/Controller 完成后，只需调参（`ActionType=Crush` 或 `Pierce`）与 RockConfig。

---

## 14. 迭代计划

- 第 1 步（当天）：落地 `PlayerToolHitEmitter`、`IResourceNode`、`TreeController` 与 `TreeConfig`，用帧窗（B）先打通。
- 第 2 步：在三向生成器中增加“命中事件注入”选项，默认在命中 60%～70% 处插入 `OnToolStrike`（切到 A）。
- 第 3 步：完善倒下动画/替换树桩与掉落表现，接入音效/VFX；联动保存与任务事件。
- 第 4 步：复制方案到挖矿（RockController + RockConfig）。

---

## 15. 风险与回滚

- 动画事件漏配：保留 B 兜底，保障基本可玩；生成器注入事件后统一解决。
- 物理误命中：通过 Layer 约束与可视化调试 Gizmos 确认 Overlap 盒大小与偏移；必要时改为 Raycast 多段判定。
- 性能：Overlap 仅在命中时刻一次调用，风险很低；可用 NonAlloc 版本。

---

以上方案在保持系统职责清晰的同时，优先采用“事件驱动 + 统一命中发射器”的最简结构，保证手感与稳定性，并为后续“挖矿”复用提供最小成本的扩展路径。
