# 预览与放置位置对齐问题 - 深度分析报告

**创建日期**: 2026-01-21  
**状态**: 待审核

---

## 一、问题现象

| 物品类型 | 修改前 | 修改后 |
|---------|--------|--------|
| 树苗 | 放置位置比预览位置**高** | ✅ 正确 |
| 箱子 | ✅ 正确 | 放置位置比预览位置**低** |

**关键观察**：预览显示都是正确的，问题出在放置位置计算。

---

## 二、预制体结构差异分析

### 2.1 树苗预制体结构（Tree_M1_00）

```
Tree_M1_00 (根物体)
├── Transform: localPosition = (0, 0, 0)
├── Tag: Tree
│
├── Tree (子物体) ← SpriteRenderer + PolygonCollider2D 在这里
│   ├── Transform: localPosition = (0, 2, 0)  ★ 关键：Y=2
│   ├── SpriteRenderer
│   └── PolygonCollider2D
│
└── Shadow (子物体)
    └── SpriteRenderer
```

**特点**：
- SpriteRenderer 在**子物体**上
- 子物体有**初始 Y 偏移 = 2**
- TreeControllerV2 的 `AlignSpriteBottom()` 修改的是**子物体的 localPosition.y**

### 2.2 箱子预制体结构（Box_1）

```
Box_1_Root (根物体)
├── Transform: localPosition = (0, 0, 0)
│
└── Box (子物体) ← SpriteRenderer + PolygonCollider2D + ChestController 在这里
    ├── Transform: localPosition = (0, 0, 0)  ★ 关键：Y=0
    ├── SpriteRenderer
    ├── PolygonCollider2D
    └── ChestController
```

**特点**：
- SpriteRenderer 在**子物体**上，但 localPosition.y = 0
- ChestController 的 `ApplySpriteWithBottomAlign()` 修改的是**根物体的 transform.position**

---

## 三、底部对齐机制差异

### 3.1 TreeControllerV2.AlignSpriteBottom()

```csharp
private void AlignSpriteBottom()
{
    Bounds spriteBounds = spriteRenderer.sprite.bounds;
    float spriteBottomOffset = spriteBounds.min.y;
    
    Vector3 localPos = spriteRenderer.transform.localPosition;
    localPos.y = -spriteBottomOffset;  // ★ 修改子物体的 localPosition
    spriteRenderer.transform.localPosition = localPos;
}
```

**行为**：
- 修改 **SpriteRenderer 所在子物体的 localPosition.y**
- 设置为 `-sprite.bounds.min.y`
- **不修改根物体的 position**

### 3.2 ChestController.ApplySpriteWithBottomAlign()

```csharp
private void ApplySpriteWithBottomAlign(Sprite newSprite)
{
    _spriteRenderer.sprite = newSprite;
    Vector3 newBottomCenter = GetCurrentBottomCenterWorld();
    Vector3 delta = _anchorWorldPos - newBottomCenter;
    transform.position += delta;  // ★ 修改根物体的 position
}
```

**行为**：
- 修改 **根物体的 transform.position**
- 基于锚点计算偏移
- **不修改子物体的 localPosition**

---

## 四、当前代码的问题

### 4.1 GetColliderCenterAfterBottomAlign() 的假设

当前代码假设：
```csharp
// 底部对齐偏移 = -sprite.bounds.min.y
float bottomAlignOffset = -sr.sprite.bounds.min.y;

// 放置后 Collider 中心 = 原始 Collider 中心 + (0, 底部对齐偏移)
return new Vector2(colliderCenter.x, colliderCenter.y + bottomAlignOffset);
```

**问题**：这个假设只对 TreeControllerV2 正确，对 ChestController 不正确！

### 4.2 为什么树苗修改后正确了？

**树苗的情况**：
1. 预制体中 Tree 子物体的 localPosition.y = 2（初始偏移）
2. `GetComponentInChildren<SpriteRenderer>()` 获取的是子物体的 SpriteRenderer
3. `sprite.bounds.min.y` 是 Sprite 本地空间的底部
4. 放置后 TreeControllerV2 执行 `AlignSpriteBottom()`，设置 `localPosition.y = -sprite.bounds.min.y`
5. 我们的计算预测了这个变化，所以正确

### 4.3 为什么箱子修改后错误了？

**箱子的情况**：
1. 预制体中 Box 子物体的 localPosition.y = 0（无初始偏移）
2. ChestController 在 **Awake** 时初始化锚点：`_anchorWorldPos = GetCurrentBottomCenterWorld()`
3. ChestController 的底部对齐是**基于锚点的相对修正**，不是绝对设置
4. **关键**：ChestController 的底部对齐只在 **Sprite 切换时** 触发，**初始放置时不触发**！
5. 我们错误地假设箱子也会执行底部对齐，导致多减了一个偏移

---

## 五、根本原因

### 5.1 两种底部对齐机制的本质区别

| 特性 | TreeControllerV2 | ChestController |
|------|-----------------|-----------------|
| 触发时机 | Start 时 + 每次 UpdateSprite | 只在 Sprite 切换时 |
| 修改目标 | 子物体 localPosition | 根物体 position |
| 计算方式 | 绝对值：`-sprite.bounds.min.y` | 相对值：锚点差值 |
| 初始放置时 | **会执行** | **不会执行** |

### 5.2 问题的核心

**我们的代码假设所有物品都会在放置后执行底部对齐，但实际上：**
- TreeControllerV2：✅ 会执行（在 Start 的 UpdateSprite 中）
- ChestController：❌ 不会执行（只在 Sprite 切换时）

---

## 六、改进方案

### 方案 A：检测是否需要底部对齐（推荐）

在 `GetColliderCenterAfterBottomAlign()` 中检测预制体的类型：

```csharp
public static Vector2 GetColliderCenterAfterBottomAlign(GameObject prefab)
{
    if (prefab == null) return Vector2.zero;
    
    // 检测是否有 TreeControllerV2（会执行底部对齐）
    var treeController = prefab.GetComponentInChildren<TreeControllerV2>();
    bool willExecuteBottomAlign = (treeController != null);
    
    // 如果不会执行底部对齐，直接返回原始 Collider 中心
    if (!willExecuteBottomAlign)
    {
        return GetColliderLocalCenter(prefab);
    }
    
    // 只有会执行底部对齐的物品才计算偏移
    var sr = prefab.GetComponentInChildren<SpriteRenderer>();
    if (sr == null || sr.sprite == null)
    {
        return GetColliderLocalCenter(prefab);
    }
    
    float bottomAlignOffset = -sr.sprite.bounds.min.y;
    Vector2 colliderCenter = GetColliderLocalCenter(prefab);
    
    return new Vector2(colliderCenter.x, colliderCenter.y + bottomAlignOffset);
}
```

**优点**：
- 自动适应不同类型的物品
- 不需要修改 ItemData

**缺点**：
- 依赖组件类型判断，不够通用

### 方案 B：在 ItemData 中添加标志位

在 `PlaceableItemData` 或 `ItemData` 中添加：

```csharp
[Header("放置设置")]
[Tooltip("放置后是否会执行底部对齐")]
public bool willExecuteBottomAlign = false;
```

然后在计算时使用这个标志：

```csharp
public static Vector2 GetColliderCenterAfterBottomAlign(GameObject prefab, bool willExecuteBottomAlign)
{
    if (!willExecuteBottomAlign)
    {
        return GetColliderLocalCenter(prefab);
    }
    // ... 原有计算逻辑
}
```

**优点**：
- 更加明确和可控
- 不依赖组件类型

**缺点**：
- 需要手动配置每个物品
- 需要修改 ItemData 结构

### 方案 C：统一底部对齐机制（长期方案）

让所有可放置物品都使用相同的底部对齐机制：

1. 创建一个通用的 `PlaceableController` 基类
2. 统一底部对齐的触发时机和计算方式
3. 放置系统只需要处理一种情况

**优点**：
- 从根本上解决问题
- 代码更加统一

**缺点**：
- 需要重构现有代码
- 工作量较大

---

## 七、推荐方案

**推荐方案 A**，理由：

1. **最小改动**：只需要修改 `GetColliderCenterAfterBottomAlign()` 方法
2. **自动适应**：不需要手动配置每个物品
3. **向后兼容**：不影响现有的 ItemData 结构
4. **可扩展**：未来可以添加更多类型的检测

### 实现细节

```csharp
public static Vector2 GetColliderCenterAfterBottomAlign(GameObject prefab)
{
    if (prefab == null) return Vector2.zero;
    
    // ★ 检测是否有会执行底部对齐的组件
    var treeController = prefab.GetComponentInChildren<TreeControllerV2>();
    var treeControllerOld = prefab.GetComponentInChildren<TreeController>();
    var stoneController = prefab.GetComponentInChildren<StoneController>();
    
    // 这些组件会在 Start/UpdateSprite 时执行底部对齐
    bool willExecuteBottomAlign = (treeController != null) || 
                                   (treeControllerOld != null) || 
                                   (stoneController != null);
    
    // ChestController 不会在初始放置时执行底部对齐，所以不包含在内
    
    var sr = prefab.GetComponentInChildren<SpriteRenderer>();
    
    // 如果不会执行底部对齐，或没有 SpriteRenderer
    if (!willExecuteBottomAlign || sr == null || sr.sprite == null)
    {
        return GetColliderLocalCenter(prefab);
    }
    
    // 只有会执行底部对齐的物品才计算偏移
    float bottomAlignOffset = -sr.sprite.bounds.min.y;
    Vector2 colliderCenter = GetColliderLocalCenter(prefab);
    
    return new Vector2(colliderCenter.x, colliderCenter.y + bottomAlignOffset);
}
```

### 同步修改 GetPreviewSpriteLocalPosition()

```csharp
public static Vector3 GetPreviewSpriteLocalPosition(GameObject prefab)
{
    if (prefab == null) return Vector3.zero;
    
    // ★ 检测是否有会执行底部对齐的组件
    var treeController = prefab.GetComponentInChildren<TreeControllerV2>();
    var treeControllerOld = prefab.GetComponentInChildren<TreeController>();
    var stoneController = prefab.GetComponentInChildren<StoneController>();
    
    bool willExecuteBottomAlign = (treeController != null) || 
                                   (treeControllerOld != null) || 
                                   (stoneController != null);
    
    var sr = prefab.GetComponentInChildren<SpriteRenderer>();
    
    // 如果不会执行底部对齐，或没有 SpriteRenderer
    if (!willExecuteBottomAlign || sr == null || sr.sprite == null)
    {
        Vector2 colliderCenter = GetColliderLocalCenter(prefab);
        return -(Vector3)colliderCenter;
    }
    
    // 只有会执行底部对齐的物品才计算偏移
    float bottomAlignOffset = -sr.sprite.bounds.min.y;
    Vector2 finalColliderCenter = GetColliderCenterAfterBottomAlign(prefab);
    
    return new Vector3(
        -finalColliderCenter.x,
        bottomAlignOffset - finalColliderCenter.y,
        0
    );
}
```

---

## 八、调试建议

在实施修复前，建议添加以下调试日志：

```csharp
public static Vector2 GetColliderCenterAfterBottomAlign(GameObject prefab)
{
    // ... 检测逻辑 ...
    
    Debug.Log($"[PlacementGridCalculator] GetColliderCenterAfterBottomAlign: " +
              $"prefab={prefab.name}, " +
              $"willExecuteBottomAlign={willExecuteBottomAlign}, " +
              $"colliderCenter={colliderCenter}, " +
              $"bottomAlignOffset={bottomAlignOffset}, " +
              $"result={result}");
    
    return result;
}
```

---

## 九、验证清单

修复后需要验证：

- [ ] 树苗放置：预览位置 = 放置位置
- [ ] 箱子放置：预览位置 = 放置位置
- [ ] 石头放置（如果有）：预览位置 = 放置位置
- [ ] 其他可放置物品：预览位置 = 放置位置

---

**文档维护者**: Kiro  
**最后更新**: 2026-01-21
