我是编码助手（锐评专家形态）。收到。指令已确认。既然你按下了“启动键”，我们就彻底摒弃之前的“修修补补”，直接进入全域重构与逻辑封锁模式。针对你提出的**“交互矩阵”与“情景预演”，我已将其转化为不可撼动的开发法则**。这不仅仅是修 Bug，这是在为游戏制定“宪法”。以下是为你准备的史诗级执行蓝图。🔒 第一部分：给项目经理的深度汇报与全景交互矩阵老板（PM），战略已定。我们现在的目标非常明确：建立一个“怎么操作都不会坏”的坚固系统。根据你的要求，我推演了所有可能的玩家操作路径，制定了以下**【交互逻辑真值表 (Interaction Truth Table)】**。这将是验收测试的唯一标准。1. 状态切换矩阵 (State Transition Rules)规则核心：UI 互斥与数据强制刷新当前状态 (Current State)输入指令 (Input)预期行为 (Expected Behavior)数据处理 (Data Action)Game Loop (无UI)E (面对箱子)打开 BoxUI (Up=箱子, Down=背包)绑定数据，刷新 UIGame Loop (无UI)TAB打开 InventoryUI (仅背包)刷新 UIBoxUI (打开中)TAB关闭 BoxUI -> 打开 InventoryUI强制刷新 背包数据BoxUI (打开中)ESC / E关闭 BoxUI -> 回到 Game Loop清理引用，释放鼠标InventoryUI (打开中)TAB / ESC关闭 InventoryUI -> 回到 Game Loop无InventoryUI (打开中)E关闭 InventoryUI -> 触发场景交互(如有)如果面前有箱子，这会导致并在下一帧打开箱子2. 操作中断与异常矩阵 (Interruption & Exception)规则核心：物品安全第一（Item Safety First）当前操作 (Operation)中断事件 (Interruption)处置逻辑 (Resolution)手持物品 (Mouse Holding)ESC / 关闭 UI退回原位。如果原位已满 -> 尝试放入背包空位 -> 背包满 -> 扔在脚下 (Spawn Drop)。绝对严禁销毁。拆分中 (Holding Ctrl/Shift)切换 Slot / 关闭 UI取消拆分。手中物品归零，原槽位恢复原数量。拖拽中 (Dragging)鼠标移出 UI 区域松开触发 丢弃逻辑 (Drop Item)。生成 WorldItemDrop，扣除背包物品。UI 切换 (Box -> Inventory)鼠标上有物品执行“手持物品关闭”逻辑（退回或丢弃），确保切换后的 UI 鼠标是空的。3. 视觉与反馈标准 (Visual & Feedback Standards)耐久度：必须显示。位置 Bottom 6px，样式 Green -> Yellow -> Red，带 1px Black Outline。空槽位：必须能够接受物品，且在数据层必须明确记录为 Empty Slot 而不是 null（防止空引用报错）。✂️ 第二部分：给执行智能体 (Kiro) 的终极指令指令来源： 架构审查委员会 (Code Reaper)任务代号： Operation Perfection (完美行动) - Full Execution执行依据： design.md, tasks.md, 及上述 交互矩阵Kiro，这是你的最后一次机会。不要给我“大概能跑”的代码。我要的是严格遵守上述矩阵、逻辑严密、即使玩家脸滚键盘也不会报错的代码。立即执行以下 5 大核心任务（按顺序）：🔧 Task 1: 建立数据安全层 (The Persistence Fix)目标：彻底解决“箱子失忆”。文件：ChestInventoryV2.cs代码要求：重写 ToSaveData()：C#// 伪代码逻辑，必须严格实现
foreach item in items:
    if item is valid:
        item.PrepareForSerialization() // 👈 必须显式调用！
        list.Add(item.ToDto())
    else:
        list.Add(EmptyDto) // 保持索引对齐
验证：Dictionary 数据必须被扁平化为 List<PropertyEntry> 存入 JSON。🔧 Task 2: 重写交互数学逻辑 (The Math Fix)目标：彻底解决“拆分吞物品”。文件：ChestInventoryV2.cs (SetItem / TryAdd)代码要求：严禁使用 _items[i] = newItem 直接覆盖，除非你确定旧物品也是空的。拆分公式：C#// 当从 slot 拿走 amount 个：
inventoryItem.amount -= takeAmount;
if (inventoryItem.amount <= 0) _items[i] = InventoryItem.Empty;
// 绝对不能让剩余的物品凭空消失
🔧 Task 3: 实现全景交互矩阵 (The Interaction Matrix)目标：处理所有按键组合。文件：GameInputManager.cs, BoxPanelUI.cs, PackagePanelTabsUI.cs代码要求：状态机：引入明确的 UI 状态判断。Box -> Tab -> Inventory：BoxPanel.Close() (触发物品退回逻辑)。InventoryPanel.Open()。InventoryPanel.RefreshAll() (关键：因为 Box 操作可能改变了背包数据，打开背包时必须重绘)。🔧 Task 4: 物品归位逻辑 (Item Recovery)目标：防止关闭 UI 时物品丢失。文件：InventoryInteractionManager.cs代码要求：实现 ReturnHeldItemToInventory() 方法。在 OnDisable 或 Close 时调用此方法。逻辑：HeldItem -> OriginSlot (如果空) -> AnyEmptySlot -> WorldDrop (兜底)。🔧 Task 5: 像素级 UI 调整 (The Polish)目标：耐久度条。文件：InventorySlotUI.cs代码要求：动态生成 Image。RectTransform 设置：AnchorMin/Max 控制宽度，AnchoredPosition.y = 6。添加 Outline 组件 (Color = Black, Width = 1)。执行模式：你可以一次性提供所有修改后的代码文件。但我要求你在代码注释中，显式标记出你修复这些逻辑的位置（例如 // FIX: Ensure Pre-Serialization）。📝 第三部分：当前进度与剩余任务清单 (Master Schedule)当前时间点： Phase 2 - 关键修正期 (Critical Fixes)📋 待完成任务 (Backlog for Kiro)[Core] ChestInventoryV2.cs 序列化逻辑重写。[Core] InventoryItem.cs 序列化辅助方法完善。[UI] InventorySlotUI.cs 耐久度条绘制代码。[Logic] SaveManager.cs 与 TimeManager.cs 的时间同步接口。[Logic] BoxPanelUI.cs 与 InventoryInteractionManager.cs 的状态切换与物品退回逻辑。🧪 验收标准 (即将进行的测试)存档闭环：存 3 个 -> 读 3 个。交互闭环：Ctrl 拆分 -> 剩余数量正确。视觉闭环：耐久度条可见且位置正确。矩阵闭环：打开箱子时按 Tab，背包能正确打开且数据是最新的。项目经理，请下令。 让 Kiro 执行这个“完美行动”方案。这将是我们通往稳定版 Beta 的关键一战。