我是编码助手（锐评专家形态）。

🔒 致项目经理（你的悄悄话）
收到。你喜欢**“手动按钮模式”**，这非常好。这不仅符合开发阶段的直觉，也更安全。自动存档虽然方便，但在架构尚未完全稳定的情况下容易把坏数据写入硬盘。我们会继续保持这种“按需存档”的模式。

Kiro 已经完成了 ChestController 的手术。现在，箱子已经有了“灵魂”（Persistent ID 和 Save/Load 能力）。

接下来，我们要把战火烧向真正的大家伙——玩家背包 (Player Inventory)。 这不仅是数据的迁移，更是对 UI 系统的巨大挑战。现在的背包代码是一坨缠绕在一起的线球（数据、UI、交互逻辑混在一起）。我们要把这个线球拆开，换上新的数据核心。

🧐 全域审视：对 Kiro 刚刚工作的裁决
我已审查了 Kiro 提交的代码：

PersistentObjectRegistry.cs: 单例实现标准，注册逻辑清晰。

SaveManager.cs: 实现了基础的 JSON 序列化，路径处理正确。

ChestInventoryV2.cs: 这是一个很好的过渡产物。它内部使用 InventoryItem，对外依然能吐出 ItemStack（虽然这有点脏，但为了兼容 UI 是必要的妥协）。

ChestController.cs: 成功实现了 IPersistentObject，并且在编辑器下自动生成 GUID。

评分：A (稳扎稳打) 他没有过度设计，而是准确执行了 MVP（最小可行性产品）策略。箱子现在已经具备了成为“永恒之物”的资格。

📋 复制给开发智能体 (Kiro) 的内容
指令来源： 架构审查委员会 (Code Reaper) 任务代号： Operation Backpack (背包行动) 阶段状态： Phase 2 - Step 3 (Player Inventory Migration)

Kiro，箱子改造成功。 你提交的 ChestController 和 ChestInventoryV2 代码结构清晰，PersistentObjectRegistry 也能正常工作。我们已经拥有了一个能够自我保存的容器。

现在，我们要攻克最难的堡垒：玩家背包 (Player Inventory)。

目前的 InventoryService 是旧时代 ItemStack 结构的大本营。它不仅管理数据，还混合了大量业务逻辑。我们需要用新时代的 InventoryItem 替换它的核心。

立即执行 Task 3: 玩家背包的数据核替换

请按照以下步骤，侵略性地重构 InventoryService：

创建 PlayerInventoryData (新内核):

类似于 ChestInventoryV2，创建一个专门管理玩家背包数据的类。

内部使用 InventoryItem[]（比如 36 格）。

提供 AddItem, RemoveItem, GetItem 等核心操作方法。

注意：这个类不应该依赖 MonoBehaviour，它只是纯粹的数据逻辑。

重构 InventoryService (换脑手术):

保留 InventoryService 这个类名（因为它被太多地方引用了，改名成本太高）。

替换 内部数据结构：将原本的 ItemStack[] items 替换为 PlayerInventoryData（或直接使用 InventoryItem[]）。

实现 IPersistentObject: 让 InventoryService 也注册到 PersistentObjectRegistry。

Save(): 返回 InventorySaveData。

Load(): 接收 InventorySaveData 并填充背包。

UI 适配层 (The Adapter):

现在的 UI (InventoryPanelUI, SlotUI) 肯定还在大量使用 ItemStack。

不要去改 UI 代码（那是无底洞）。

在 InventoryService 对外暴露的接口中（如 GetItem(int index)），动态转换：

当 UI 请求数据时：return inventoryItem.ToItemStack();

这样 UI 依然以为自己在和旧系统打交道，但底层的“账本”已经变成了支持耐久度和附魔的新账本。

验证目标：

启动游戏。

捡起一把工具（确保它变成了 InventoryItem 并存入背包）。

使用工具消耗耐久度（修改 InventoryItem 的 currentDurability）。

点击保存按钮（触发 SaveManager，此时应该同时保存箱子和背包）。

重启游戏 -> 加载。

玩家背包里的工具应该还在，且耐久度损耗保持一致。

特殊指令：

不要 在本次任务中重写 InventoryPanelUI。那是 Phase 3 的任务。现在只做数据层的“偷天换日”。

确保 SaveManager 在保存时，能同时收集到 ChestController（箱子）和 InventoryService（背包）的数据。

行动吧。 这是一个高风险手术，请务必小心。