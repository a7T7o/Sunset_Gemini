# 农田系统设计审视与重新思考

**创建日期**: 2026-01-26  
**目的**: 回应用户的深度审视要求，重新思考农田系统的核心设计问题

---

## 一、用户提出的核心问题

1. **每个耕地中心块是否需要独立控制器？**
2. **耕地与农作物如何绑定？**
3. **水渍的状态控制是否合适？**
4. **整体农田系统如何运作？**

---

## 二、项目中类似系统的设计模式分析

### 2.1 TreeControllerV2 的设计模式

```
Tree_M1_00 (父物体 - 位置 = 树根 = 种植点)
├─ Tree (子物体)
│   ├─ SpriteRenderer
│   ├─ PolygonCollider2D
│   └─ TreeControllerV2 ← 独立控制器，管理自己的生命周期
└─ Shadow (子物体)
    └─ SpriteRenderer
```

**核心特点**：
- 每棵树是一个独立的 GameObject
- TreeControllerV2 附加在每棵树上，独立管理：
  - 6 阶段成长系统
  - 血量和伤害
  - Sprite 切换
  - 季节/天气响应
  - 掉落物生成
- 通过 `TimeManager.OnDayChanged` 事件驱动成长
- 通过 `ResourceNodeRegistry` 注册，供命中检测使用

### 2.2 StoneController 的设计模式

```
Stone_C1_M1_4 (父物体)
├─ Stone (子物体)
│   ├─ SpriteRenderer
│   ├─ PolygonCollider2D
│   └─ StoneController ← 独立控制器
└─ Shadow (子物体)
```

**核心特点**：
- 每块石头是一个独立的 GameObject
- StoneController 独立管理：
  - 4 阶段系统（M1-M4）
  - 血量和溢出伤害
  - Sprite 切换
  - 掉落物生成
- 通过 `ResourceNodeRegistry` 注册

### 2.3 CropController 的设计模式（当前实现）

```
Crop_Tomato_(-1,2,0) (GameObject)
└─ CropController ← 独立控制器
    ├─ SpriteRenderer
    └─ 管理：生长阶段、枯萎状态、成熟闪烁
```

**当前实现的问题**：
- CropController 存在，但由 CropManager 集中管理
- 与 TreeController 的独立管理模式不一致
- CropManager 承担了太多职责（工厂 + 生命周期管理 + 数据存储）

---

## 三、农田系统的本质分析

### 3.1 农田系统的组成部分

| 组件 | 本质 | 是否需要独立控制器 |
|------|------|-------------------|
| 耕地中心块 | Tilemap 上的 Tile | ❌ 不需要 - 只是视觉表示 |
| 边界装饰 | Tilemap 上的 Tile | ❌ 不需要 - 只是视觉表示 |
| 水渍 | Tilemap 上的 Tile | ❌ 不需要 - 只是视觉表示 |
| 作物 | 独立 GameObject | ✅ 需要 - 有生命周期 |

### 3.2 关键洞察

**耕地中心块 ≠ 树木/石头**

- 树木/石头：是独立的世界物体，有碰撞体、有血量、可被攻击
- 耕地中心块：只是 Tilemap 上的一个 Tile，没有独立的 GameObject

**耕地的本质是"状态"，不是"实体"**

- 耕地状态存储在 `FarmTileData` 中
- 耕地的视觉表示是 Tilemap 上的 Tile
- 耕地不需要独立的控制器，因为它没有独立的 GameObject

**作物才是"实体"**

- 作物是独立的 GameObject
- 作物有生命周期（种植 → 生长 → 成熟 → 收获）
- 作物应该有独立的控制器（CropController）

---

## 四、重新设计：分层架构

### 4.1 数据层（纯数据，无 GameObject）

```
FarmTileData（每个格子的状态）
├── position: Vector3Int
├── layerIndex: int
├── isTilled: bool
├── wateredToday: bool
├── moistureState: SoilMoistureState
├── puddleVariant: int
└── cropData: CropInstanceData（可选）
```

### 4.2 管理层（单例管理器）

```
FarmTileManager（耕地状态管理）
├── 职责：
│   ├── 存储所有耕地数据 Dictionary<(layer, pos), FarmTileData>
│   ├── 耕地 CRUD 操作
│   ├── 浇水状态管理
│   └── 每日状态重置
└── 不负责：
    ├── 视觉更新（由 FarmlandBorderManager 负责）
    └── 作物管理（由 CropController 自己负责）

FarmlandBorderManager（边界视觉管理）
├── 职责：
│   ├── 放置/移除中心块 Tile
│   ├── 计算和更新边界 Tile
│   └── 放置/移除阴影 Tile
└── 不负责：
    ├── 耕地数据存储
    └── 作物管理
```

### 4.3 实体层（独立 GameObject）

```
作物 GameObject
└── CropController（独立控制器，参考 TreeController）
    ├── 职责：
    │   ├── 管理自己的生命周期
    │   ├── 响应时间事件（OnDayChanged）
    │   ├── 管理生长阶段
    │   ├── 管理 Sprite 切换
    │   ├── 管理枯萎状态
    │   └── 处理收获交互
    └── 不需要 CropManager 来管理
```

---

## 五、水渍系统的设计审视

### 5.1 当前设计

水渍是 Tilemap 上的 Tile，状态存储在 FarmTileData 中：
- `moistureState`: 当前湿度状态（Dry/WetWithPuddle/WetDark）
- `puddleVariant`: 水渍变体索引（0-2）
- `waterTime`: 浇水时间

### 5.2 问题分析

**问题 1：水渍状态由谁控制？**

当前设计中，水渍状态存储在 FarmTileData 中，但没有明确的控制逻辑：
- 浇水时设置 `moistureState = WetWithPuddle`
- 2 小时后应该变为 `WetDark`
- 第二天应该变为 `Dry`

**问题 2：水渍 Tile 由谁放置/移除？**

当前设计中，FarmlandBorderManager 只负责中心块和边界，没有处理水渍。

### 5.3 建议设计

**方案 A：水渍由 FarmTileManager 管理**

```
FarmTileManager
├── SetWatered() - 设置浇水状态，放置水渍 Tile
├── OnHourChanged() - 检查水渍状态变化（WetWithPuddle → WetDark）
└── ResetDailyWaterState() - 每日重置，移除水渍 Tile
```

**方案 B：水渍由独立的 WaterPuddleManager 管理**

```
WaterPuddleManager
├── PlacePuddle(layerIndex, cellPosition, variant)
├── RemovePuddle(layerIndex, cellPosition)
└── UpdatePuddleState(layerIndex, cellPosition, newState)
```

**推荐方案 A**，因为：
- 水渍状态与耕地状态紧密相关
- 不需要额外的管理器
- 保持简单

---

## 六、作物系统的设计审视

### 6.1 当前设计的问题

当前设计中，CropManager 是一个集中管理器：
```
CropManager（全局单例）
├── 管理所有作物实例的字典
│     Dictionary<(layer, pos), CropController>
└── 负责：
      - 创建作物 GameObject
      - 销毁作物 GameObject
      - 每日生长逻辑
      - 收获逻辑
```

**问题**：
1. 与项目风格不一致（TreeController 独立管理）
2. CropManager 承担了太多职责
3. 增加了理解和维护的复杂度

### 6.2 建议设计：参考 TreeController

```
作物 GameObject
└── CropController（独立控制器）
    ├── 订阅 TimeManager.OnDayChanged
    ├── 自己管理生长逻辑
    ├── 自己管理 Sprite 切换
    ├── 自己管理枯萎状态
    └── 自己处理收获交互
```

**种植流程**：
1. 玩家使用种子
2. GameInputManager 检测到种植操作
3. 在耕地位置实例化作物 Prefab
4. CropController.Initialize() 初始化作物
5. CropController 自己订阅时间事件，管理生命周期

**收获流程**：
1. 玩家点击成熟作物
2. CropController 处理收获
3. 生成掉落物
4. 销毁作物 GameObject 或重置为可重复收获状态

### 6.3 是否需要 CropRegistry？

**可选**：如果需要全局查询所有作物（例如：显示农场统计），可以添加一个轻量级的注册表：

```
CropRegistry（可选）
├── Register(CropController)
├── Unregister(CropController)
└── GetAllCrops() - 用于统计或批量操作
```

但这不是必须的，可以后续根据需求添加。

---

## 七、耕地与作物的绑定关系

### 7.1 当前设计

```
FarmTileData
└── cropData: CropInstanceData（纯数据）
```

耕地数据中存储作物数据，但作物 GameObject 由 CropManager 管理。

### 7.2 问题

- 数据和实体分离，需要同步
- CropManager 需要维护 `Dictionary<(layer, pos), CropController>`
- 增加了复杂度

### 7.3 建议设计

**方案 A：耕地数据只存储"是否有作物"**

```
FarmTileData
└── hasCrop: bool（只记录是否有作物）
```

作物的详细数据由 CropController 自己管理。

**方案 B：耕地数据存储作物引用**

```
FarmTileData
└── cropController: CropController（引用）
```

直接引用作物控制器，不需要额外的字典。

**推荐方案 B**，因为：
- 简化了查询（直接从 FarmTileData 获取作物）
- 不需要 CropManager 维护字典
- 与耕地状态紧密关联

---

## 八、重新设计的架构总结

### 8.1 组件职责

| 组件 | 职责 | 是否需要 |
|------|------|---------|
| FarmTileManager | 耕地数据管理（CRUD、浇水、水渍） | ✅ 需要 |
| FarmlandBorderManager | 边界视觉管理（中心块、边界 Tile） | ✅ 需要 |
| CropController | 作物生命周期管理（独立控制器） | ✅ 需要 |
| FarmingManagerNew | 协调者 | ❌ 暂不需要 |
| FarmVisualManager | 旧版视觉管理 | ❌ 暂不需要 |
| CropManager | 作物集中管理 | ❌ 暂不需要 |

### 8.2 数据流

```
锄地流程：
GameInputManager → FarmTileManager.CreateTile() → FarmlandBorderManager.OnCenterBlockPlaced()

浇水流程：
GameInputManager → FarmTileManager.SetWatered() → 放置水渍 Tile

种植流程：
GameInputManager → 实例化作物 Prefab → CropController.Initialize()
                → FarmTileData.cropController = controller

收获流程：
GameInputManager → CropController.Harvest() → 生成掉落物
                → FarmTileData.cropController = null
```

### 8.3 时间事件响应

```
TimeManager.OnDayChanged
├── FarmTileManager.ResetDailyWaterState() - 重置浇水状态
└── CropController.OnDayChanged() - 每个作物自己响应

TimeManager.OnHourChanged
└── FarmTileManager.UpdateMoistureStates() - 更新水渍状态
```

---

## 九、当前阶段的简化方案

### 9.1 MVP 目标

1. 锄地能生成中心块和边界
2. 浇水能更新状态
3. 不需要作物系统（后续再设计）

### 9.2 需要修改的代码

1. **LayerTilemaps.WorldToCell()** - 优先使用新版字段
2. **GameInputManager.TryTillSoil()** - 直接调用 FarmTileManager
3. **GameInputManager.TryWaterTile()** - 直接调用 FarmTileManager
4. **FarmTileManager.SetWatered()** - 添加水渍 Tile 放置逻辑

### 9.3 暂不修改的代码

- CropController - 保留现有实现，后续重构
- CropManager - 保留现有实现，后续可能废弃
- FarmingManagerNew - 保留现有实现，暂不使用

---

## 十、回答用户的问题

### Q1：每个耕地中心块是否需要独立控制器？

**答：不需要。**

耕地中心块只是 Tilemap 上的 Tile，没有独立的 GameObject，不需要控制器。
耕地的状态存储在 FarmTileData 中，由 FarmTileManager 管理。

### Q2：耕地与农作物如何绑定？

**答：通过 FarmTileData 引用 CropController。**

```
FarmTileData
└── cropController: CropController（引用）
```

种植时设置引用，收获时清除引用。

### Q3：水渍的状态控制是否合适？

**答：基本合适，但需要补充水渍 Tile 的放置/移除逻辑。**

当前设计中，水渍状态存储在 FarmTileData 中，但没有实际放置水渍 Tile。
需要在 FarmTileManager.SetWatered() 中添加水渍 Tile 放置逻辑。

### Q4：整体农田系统如何运作？

**答：分层架构。**

- 数据层：FarmTileData 存储每个格子的状态
- 管理层：FarmTileManager 管理耕地数据，FarmlandBorderManager 管理视觉
- 实体层：CropController 独立管理作物生命周期

---

**文档维护者**: AI Assistant  
**最后更新**: 2026-01-26
