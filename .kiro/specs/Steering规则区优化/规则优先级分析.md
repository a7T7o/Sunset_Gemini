# Steering 规则优先级分析文档

## 文档说明

本文档对项目中所有 steering 规则文件进行分类、优先级评估和优化建议。

**生成时间**: 2025-01-08  
**最后更新**: 2025-01-09  
**规则总数**: 19 个文件（已从 21 个优化）  
**总字符数**: 约 42,000+ 字符

### 已完成的优化（2025-01-09）

| 操作 | 文件 | 说明 |
|------|------|------|
| ✅ 删除 | `context-handoff.md` | 内容过时（2025-12-12的任务状态） |
| ✅ 删除 | `tree-system.md` | 数据已合并到 `trees.md` |
| ✅ 合并 | `trees.md` | 添加了6阶段系统核心规则（游戏数值表） |
| ✅ 迁移 | `rules.md` | 添加了全局 Tag/Layer 多选规范 |
| ✅ 简化 | `ui.md` | 移除已迁移的编辑器规范，改为引用 |
| ✅ 简化 | `trees.md` | 层级结构改为引用 `layers.md` |

---

## 一、规则分类

### 1. 核心架构规则（必读 - 最高优先级）

这些规则定义了项目的基础架构和最容易犯的严重错误，必须在每次对话开始时加载。

| 规则文件 | 用途 | 字符数估算 | 使用频率 |
|---------|------|-----------|---------|
| `rules.md` | 开发规则与禁止事项（玩家位置、碰撞体、遮挡系统等核心规则） | ~4,500 | 极高 |
| `layers.md` | 项目层级设计规范（楼层结构、Sorting Layers、命中检测） | ~5,000 | 极高 |
| `workspace-memory.md` | 工作区记忆规范（specs 目录结构、memory.md 规范） | ~3,500 | 极高 |
| `communication.md` | 沟通规范（一条龙模式、语言要求、方案讨论） | ~3,000 | 极高 |

**小计**: 4 个文件，约 16,000 字符

**核心原因**:
- `rules.md` - 包含最容易犯的严重错误（玩家位置、碰撞体用途、遮挡系统）
- `layers.md` - 定义整个项目的层级架构，几乎所有功能都依赖此规则
- `workspace-memory.md` - 定义工作流程，每次对话都需要遵守
- `communication.md` - 定义对话模式和语言要求，影响所有交互

---

### 2. 系统规范（高频使用 - 高优先级）

这些规则描述具体系统的实现规范，在开发相关功能时必须参考。

| 规则文件 | 用途 | 字符数估算 | 使用频率 |
|---------|------|-----------|---------|
| `animation.md` | 动画系统规范（帧同步、动画ID映射、工具类型映射） | ~3,500 | 高 |
| `ui.md` | UI 系统规范（面板层级、快捷键、工具栏、Tag多选） | ~4,000 | 高 |
| `so-design.md` | ScriptableObject 设计规范（ID分配、品质系统、工具同步） | ~3,000 | 高 |
| `items.md` | 物品系统规范（ID分配、数据结构、品质系统、背包） | ~2,500 | 高 |
| `systems.md` | 核心系统设计规范（时间、季节、遮挡、导航、Order计算） | ~3,500 | 高 |
| `trees.md` | 树木系统规范（层级结构、TreeController、导航同步） | ~2,500 | 中高 |

**小计**: 6 个文件，约 19,000 字符

**使用场景**:
- 开发动画相关功能时需要 `animation.md`
- 开发 UI 功能时需要 `ui.md`
- 创建或修改物品数据时需要 `so-design.md` 和 `items.md`
- 开发时间、导航、遮挡功能时需要 `systems.md`
- 处理树木相关功能时需要 `trees.md`

---

### 3. 开发规范（中频参考 - 中优先级）

这些规则提供编码标准和文档规范，在编写代码或文档时参考。

| 规则文件 | 用途 | 字符数估算 | 使用频率 |
|---------|------|-----------|---------|
| `coding-standards.md` | 编码规范（命名、代码组织、事件系统、对象池） | ~4,000 | 中 |
| `documentation.md` | 技术文档编写规范（日志式记录、用户反馈记录） | ~3,500 | 中 |
| `scene-modification-rule.md` | 场景/组件修改规则（审视原有配置、征求同意） | ~1,500 | 中 |
| `scene-hierarchy-sync.md` | 场景层级同步规则（更新文档、检查清单） | ~1,500 | 低 |

**小计**: 4 个文件，约 10,500 字符

**使用场景**:
- 编写新代码时参考 `coding-standards.md`
- 编写技术文档时参考 `documentation.md`
- 修改场景配置时参考 `scene-modification-rule.md`
- 修改场景层级时参考 `scene-hierarchy-sync.md`（但实际使用频率很低）

---

### 4. 项目信息（低频参考 - 低优先级）

这些规则提供项目背景信息，不影响具体开发工作。

| 规则文件 | 用途 | 字符数估算 | 使用频率 |
|---------|------|-----------|---------|
| `product.md` | 产品概述（项目介绍、核心概念、开发状态） | ~1,500 | 低 |
| `tech.md` | 技术栈（Unity版本、包管理、架构模式） | ~2,000 | 低 |
| `structure.md` | 项目结构（文件夹组织、命名规范、场景结构） | ~3,500 | 低 |
| `progress.md` | 项目进度与状态（模块完成情况、技术突破） | ~4,000 | 低 |

**小计**: 4 个文件，约 11,000 字符

**使用场景**:
- 新成员了解项目时参考
- 需要查看项目整体进度时参考
- 实际开发中很少需要

---

### 5. 特定系统（按需加载 - 可选优先级）

这些规则描述特定系统的实现细节，只在开发相关功能时需要。

| 规则文件 | 用途 | 字符数估算 | 使用频率 |
|---------|------|-----------|---------|
| `farming.md` | 农田系统规范（土壤状态、时间集成、作物生长） | ~2,500 | 按需 |

**小计**: 1 个文件，约 2,500 字符

**使用场景**:
- 只在开发农田系统时需要

---

### 6. 过时/冗余规则（已清理）

~~这些规则内容过时、重复或很少使用。~~

| 规则文件 | 状态 | 处理结果 |
|---------|------|---------|
| `context-handoff.md` | ✅ 已删除 | 内容过时（2025-12-12的任务状态） |
| `tree-system.md` | ✅ 已删除 | 数据已合并到 `trees.md` |

**小计**: 0 个文件（已清理完毕）

---

## 二、优先级总结

### P0 - 核心架构规则（必读）

**必须在每次对话开始时加载**

1. `rules.md` - 开发规则与禁止事项
2. `layers.md` - 项目层级设计规范
3. `workspace-memory.md` - 工作区记忆规范
4. `communication.md` - 沟通规范

**理由**: 这些规则定义了项目的基础架构和最容易犯的严重错误，违反这些规则会导致严重问题。

---

### P1 - 系统规范（高频使用）

**在开发相关功能时必须加载**

5. `animation.md` - 动画系统规范
6. `ui.md` - UI 系统规范
7. `so-design.md` - ScriptableObject 设计规范
8. `items.md` - 物品系统规范
9. `systems.md` - 核心系统设计规范
10. `trees.md` - 树木系统规范

**理由**: 这些规则描述具体系统的实现规范，在开发相关功能时必须参考，但不是每次对话都需要。

---

### P2 - 开发规范（中频参考）

**在编写代码或文档时参考**

11. `coding-standards.md` - 编码规范
12. `documentation.md` - 技术文档编写规范
13. `scene-modification-rule.md` - 场景/组件修改规则
14. `scene-hierarchy-sync.md` - 场景层级同步规则

**理由**: 这些规则提供编码标准和文档规范，但不是每次都需要参考。

---

### P3 - 项目信息（低频参考）

**新成员了解项目时参考，实际开发中很少需要**

15. `product.md` - 产品概述
16. `tech.md` - 技术栈
17. `structure.md` - 项目结构
18. `progress.md` - 项目进度与状态

**理由**: 这些规则提供项目背景信息，不影响具体开发工作。

---

### P4 - 特定系统（按需加载）

**只在开发相关功能时需要**

19. `farming.md` - 农田系统规范

**理由**: 只在开发特定系统时需要，不应该默认加载。

---

### P5 - 过时/冗余（已清理）

~~**建议删除或移至归档**~~

~~20. `context-handoff.md` - 对话继承上下文（内容过时）~~
~~21. `tree-system.md` - 树木系统规范（可能与 trees.md 重复）~~

**状态**: ✅ 已全部清理完毕

**处理结果**:
- `context-handoff.md` - 已删除（内容过时）
- `tree-system.md` - 数据已合并到 `trees.md` 后删除

---

## 三、上下文消耗分析

### 当前状态（优化后）

- **规则总数**: 19 个文件（从 21 个减少）
- **总字符数**: 约 42,000+ 字符（从 45,000+ 减少）
- **Token 估算**: 约 10,000-12,000 tokens（按 3.5-4 字符/token 计算）
- **已节省**: 约 7% 的上下文

### 优化后状态

#### 方案 A：最小核心集（推荐）

**只加载 P0 核心规则**

- **规则数量**: 4 个文件
- **总字符数**: 约 16,000 字符
- **Token 估算**: 约 4,000-4,500 tokens
- **节省**: 约 65% 的上下文

**优点**:
- 大幅减少上下文消耗
- 保留最关键的规则
- 其他规则按需加载

**缺点**:
- 需要在开发特定功能时手动加载相关规则

---

#### 方案 B：核心+高频集

**加载 P0 + P1 规则**

- **规则数量**: 10 个文件
- **总字符数**: 约 35,000 字符
- **Token 估算**: 约 8,500-9,500 tokens
- **节省**: 约 25% 的上下文

**优点**:
- 覆盖大部分常用规则
- 减少手动加载的频率

**缺点**:
- 仍然消耗较多上下文

---

#### 方案 C：智能加载（最优）

**根据对话内容动态加载规则**

- **默认加载**: P0 核心规则（4 个文件，约 16,000 字符）
- **关键词触发**: 检测对话中的关键词，自动加载相关规则
  - 提到"动画"、"工具"、"同步" → 加载 `animation.md`
  - 提到"UI"、"面板"、"快捷键" → 加载 `ui.md`
  - 提到"物品"、"背包"、"SO" → 加载 `so-design.md` 和 `items.md`
  - 提到"树木"、"树林" → 加载 `trees.md`
  - 提到"农田"、"种植" → 加载 `farming.md`

**优点**:
- 最小化默认上下文消耗
- 自动加载相关规则，无需手动干预
- 最灵活的方案

**缺点**:
- 需要实现关键词检测机制（但 Kiro 可能已支持）

---

## 四、优化建议

### 1. 立即执行（✅ 已完成）

#### 1.1 删除过时规则

- ✅ **已删除** `context-handoff.md` - 内容过时（2025-12-12的任务状态）
- ✅ **已删除** `tree-system.md` - 数据已合并到 `trees.md`

#### 1.2 合并重复内容

- ✅ **已合并** `tree-system.md` 的6阶段系统核心规则到 `trees.md`
- ✅ **已迁移** `ui.md` 的 Tag/Layer 多选规范到 `rules.md`
- [ ] **待检查** `so-design.md` 和 `items.md` 是否有重复内容可以合并

#### 1.3 精简低频规则

- [ ] **待精简** `progress.md` - 只保留最新的进度信息，删除过时内容
- [ ] **待精简** `product.md` - 只保留核心概念，删除详细的开发状态

---

### 2. 中期优化（中优先级）

#### 2.1 规则分层加载

实现三层加载机制：

1. **默认层（P0）**: 每次对话自动加载
   - `rules.md`
   - `layers.md`
   - `workspace-memory.md`
   - `communication.md`

2. **按需层（P1-P2）**: 根据对话内容或用户请求加载
   - 系统规范（animation, ui, so-design, items, systems, trees）
   - 开发规范（coding-standards, documentation, scene-modification-rule）

3. **归档层（P3-P4）**: 移至单独的归档目录，需要时手动加载
   - 项目信息（product, tech, structure, progress）
   - 特定系统（farming）

#### 2.2 创建规则索引

创建 `.kiro/steering/README.md` 文件，列出所有规则的：
- 名称和用途
- 优先级
- 使用场景
- 关键词触发条件

---

### 3. 长期优化（低优先级）

#### 3.1 规则模块化

将大型规则文件拆分为更小的模块：

- `rules.md` → 拆分为 `rules-core.md`（核心规则）和 `rules-api.md`（API规范）
- `systems.md` → 拆分为 `systems-time.md`、`systems-navigation.md`、`systems-occlusion.md`

#### 3.2 规则版本管理

为规则文件添加版本号和更新日期：

```markdown
---
version: 2.0
last_updated: 2025-01-08
priority: P0
keywords: [玩家位置, 碰撞体, 遮挡系统]
---
```

---

## 五、实施计划

### 阶段 1：立即清理（本次对话完成）

- [ ] 删除 `context-handoff.md`
- [ ] 检查并处理 `tree-system.md`
- [ ] 精简 `progress.md` 和 `product.md`

### 阶段 2：重组结构（下次对话）

- [ ] 创建 `.kiro/steering/README.md` 索引文件
- [ ] 创建 `.kiro/steering/archive/` 归档目录
- [ ] 移动低频规则到归档目录

### 阶段 3：测试优化效果（后续）

- [ ] 测试只加载 P0 规则的效果
- [ ] 收集实际使用中的反馈
- [ ] 根据反馈调整优先级

---

## 六、预期效果

### 上下文节省

- **当前**: 约 11,000-13,000 tokens
- **优化后（方案 A）**: 约 4,000-4,500 tokens
- **节省**: 约 65%

### 加载速度提升

- **当前**: 需要处理 21 个文件
- **优化后**: 只需处理 4 个核心文件
- **提升**: 约 80%

### 维护性提升

- 规则分类清晰，易于查找
- 过时规则及时清理
- 新规则添加有明确的优先级指导

---

## 七、关键词触发表（方案 C 参考）

| 关键词 | 触发规则 | 优先级 |
|--------|---------|--------|
| 动画、工具、同步、帧 | `animation.md` | P1 |
| UI、面板、快捷键、Toggle | `ui.md` | P1 |
| 物品、背包、SO、ScriptableObject | `so-design.md`, `items.md` | P1 |
| 树木、树林、TreeController | `trees.md` | P1 |
| 时间、季节、导航、遮挡 | `systems.md` | P1 |
| 农田、种植、作物 | `farming.md` | P4 |
| 编码、命名、Region | `coding-standards.md` | P2 |
| 文档、日志、记录 | `documentation.md` | P2 |
| 场景、组件、修改 | `scene-modification-rule.md` | P2 |

---

## 八、总结

### 核心问题

1. **规则过多**: 21 个文件，约 45,000 字符
2. **优先级不明确**: 所有规则都被平等加载
3. **存在冗余**: 部分规则内容过时或重复

### 解决方案

1. **分层加载**: P0 核心规则默认加载，其他按需加载
2. **清理冗余**: 删除过时规则，合并重复内容
3. **智能触发**: 根据关键词自动加载相关规则

### 预期收益

- **上下文节省**: 约 65%
- **加载速度**: 提升约 80%
- **维护性**: 显著提升

---

**建议**: 优先实施方案 A（最小核心集），然后根据实际使用情况逐步优化。
