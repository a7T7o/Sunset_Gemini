# 背包交互系统 - 详细交互状态表

## 核心概念澄清

### 槽位状态定义
| 状态 | ItemId | Amount | 说明 |
|------|--------|--------|------|
| 空槽位 | -1 | 0 | 没有物品，可以放置 |
| 有物品 | ≥0 | ≥1 | 有物品，可以拿取/交换 |

### 系统状态定义
| 状态 | 说明 | 进入条件 | 退出条件 |
|------|------|----------|----------|
| **Idle（空闲）** | 手上没有物品 | 初始状态 / 放置成功 / 返回原位 | 拿起物品 |
| **HeldByShift** | 通过 Shift+左键 拿起物品 | Shift+左键按下在有物品槽位 | 放置 / 返回原位 / ESC |
| **HeldByCtrl** | 通过 Ctrl+左键 拿起物品 | Ctrl+左键按下在有物品槽位 | 放置 / 返回原位 / ESC |
| **Dragging** | 通过长按拖拽拿起物品 | 无修饰键长按0.15秒+移动5像素 | 松开左键 |

---

## 状态转换图

```
                    ┌─────────────────────────────────────────┐
                    │                                         │
                    ▼                                         │
              ┌──────────┐                                    │
              │   Idle   │◄───────────────────────────────────┤
              │ (空闲)   │                                    │
              └────┬─────┘                                    │
                   │                                          │
     ┌─────────────┼─────────────┬────────────────────┐       │
     │             │             │                    │       │
     ▼             ▼             ▼                    │       │
┌─────────┐  ┌─────────┐  ┌──────────┐               │       │
│HeldBy   │  │HeldBy   │  │ Dragging │               │       │
│Shift    │  │Ctrl     │  │ (拖拽)   │               │       │
└────┬────┘  └────┬────┘  └────┬─────┘               │       │
     │            │            │                      │       │
     │            │            │                      │       │
     └────────────┴────────────┴──────────────────────┘       │
                   │                                          │
                   │ 放置成功/返回原位/ESC                     │
                   └──────────────────────────────────────────┘
```

---

## 详细交互矩阵

### 一、Idle 状态（手上没有物品）

| 输入 | 目标槽位 | 操作结果 | 新状态 |
|------|----------|----------|--------|
| **左键单击** | 空槽位 | 无操作（Toggle 选中效果） | Idle |
| **左键单击** | 有物品 | 无操作（Toggle 选中效果） | Idle |
| **Shift+左键按下** | 空槽位 | 无操作 | Idle |
| **Shift+左键按下** | 有物品 | 拿起一半（向下取整），原槽位保留另一半 | HeldByShift |
| **Ctrl+左键按下** | 空槽位 | 无操作 | Idle |
| **Ctrl+左键按下** | 有物品（非装备类） | 拿起 1 个，原槽位减 1 | HeldByCtrl |
| **Ctrl+左键按下** | 有物品（装备类，在 Up 区域） | 快速装备到对应槽位 | Idle |
| **Ctrl+长按** | 有物品 | 持续拿取（每秒 3-4 个） | HeldByCtrl |
| **长按0.15秒+移动5像素** | 空槽位 | 无操作 | Idle |
| **长按0.15秒+移动5像素** | 有物品 | 拿起全部，原槽位清空，进入拖拽 | Dragging |
| **Shift+Ctrl+左键** | 任意 | 无操作（冲突忽略） | Idle |

---

### 二、HeldByShift 状态（Shift 拿起，手上有物品）

**关键理解**：Shift 拿起后，物品跟随鼠标，等待玩家**再次点击**来放置

| 输入 | 目标槽位 | 操作结果 | 新状态 |
|------|----------|----------|--------|
| **左键单击** | 空槽位 | 放置手上物品到该槽位 | Idle |
| **左键单击** | 有相同物品 | 堆叠（不超过上限），剩余留手上 | Idle 或保持 |
| **左键单击** | 有不同物品 | **返回原位**（不交换！） | Idle |
| **Shift+左键单击** | 源槽位 | 连续二分（手上数量减半，返回原槽位） | HeldByShift |
| **Shift+左键单击** | 空槽位 | 放置手上物品到该槽位 | Idle |
| **Shift+左键单击** | 有相同物品 | 堆叠 | Idle 或保持 |
| **Shift+左键单击** | 有不同物品 | **返回原位** | Idle |
| **左键单击** | PackagePanel 外部 | 丢弃物品（生成掉落物） | Idle |
| **ESC** | - | 返回原位 | Idle |

**⚠️ 关键点**：
- Shift 拿起后，**松开鼠标不会触发任何操作**
- 必须**再次点击**才会放置
- 点击有不同物品的槽位 → **返回原位**，不是交换

---

### 三、HeldByCtrl 状态（Ctrl 拿起，手上有物品）

**关键理解**：Ctrl 拿起后，物品跟随鼠标，等待玩家**再次点击**来放置

| 输入 | 目标槽位 | 操作结果 | 新状态 |
|------|----------|----------|--------|
| **左键单击** | 空槽位 | 放置手上物品到该槽位 | Idle |
| **左键单击** | 有相同物品 | 堆叠 | Idle 或保持 |
| **左键单击** | 有不同物品 | **返回原位**（不交换！） | Idle |
| **Ctrl+长按** | 源槽位 | 继续从源槽位拿取（每秒 3-4 个） | HeldByCtrl |
| **左键单击** | PackagePanel 外部 | 丢弃物品 | Idle |
| **ESC** | - | 返回原位 | Idle |

**⚠️ 关键点**：
- Ctrl 拿起后，**松开鼠标不会触发任何操作**
- 必须**再次点击**才会放置
- 点击有不同物品的槽位 → **返回原位**，不是交换

---

### 四、Dragging 状态（拖拽中）

**关键理解**：拖拽是**按住左键不松开**的状态，**松开左键立即执行放置判定**

| 输入 | 目标槽位 | 操作结果 | 新状态 |
|------|----------|----------|--------|
| **松开左键** | 空槽位 | 放置物品到该槽位 | Idle |
| **松开左键** | 有相同物品 | 堆叠 | Idle |
| **松开左键** | 有不同物品 | **交换**两个槽位的物品 | Idle |
| **松开左键** | PackagePanel 外部 | 丢弃物品 | Idle |
| **松开左键** | 源槽位 | 返回原位 | Idle |
| **ESC（按住左键时）** | - | 返回原位 | Idle |

**⚠️ 关键点**：
- 拖拽状态下，**松开左键立即执行**
- 拖拽到不同物品 → **交换**（与 Shift/Ctrl 不同！）
- 拖拽期间 Shift/Ctrl 被忽略

---

## 核心区别总结

| 特性 | Shift/Ctrl 拿起 | 拖拽 |
|------|-----------------|------|
| 触发方式 | 修饰键+左键**按下** | 无修饰键长按+移动 |
| 物品跟随 | 跟随鼠标 | 跟随鼠标 |
| 放置触发 | **再次点击** | **松开左键** |
| 遇到不同物品 | **返回原位** | **交换** |
| 原槽位状态 | 保留剩余数量 | 清空 |

---

## 事件处理逻辑（伪代码）

### PointerDown 事件
```
if (Shift && Ctrl) → 忽略
if (Shift && 有物品) → 执行 ShiftPickup，进入 HeldByShift
if (Ctrl && 有物品) → 执行 CtrlPickup，进入 HeldByCtrl
if (无修饰键) → 记录按下时间和位置，等待拖拽判定
```

### PointerUp 事件
```
if (当前是 Dragging 状态) → 已由 EndDrag 处理，忽略
if (当前是 Idle 状态) → 普通点击，让 Toggle 处理
// PointerUp 不应该触发 Shift/Ctrl 的放置逻辑！
```

### BeginDrag 事件
```
if (已经是 HeldByShift 或 HeldByCtrl) → 忽略，不进入拖拽
if (无修饰键 && 长按超过0.15秒 && 有物品) → 执行 StartDrag，进入 Dragging
```

### EndDrag 事件
```
if (当前是 Dragging 状态) → 执行放置判定（交换/堆叠/丢弃）
```

### 再次点击（Held 状态下的 PointerDown）
```
if (当前是 HeldByShift 或 HeldByCtrl) {
    if (点击空槽位) → 放置
    if (点击相同物品) → 堆叠
    if (点击不同物品) → 返回原位
    if (点击源槽位 && 按住 Shift) → 连续二分
    if (点击 PackagePanel 外部) → 丢弃
}
```

---

## 当前代码的核心错误

### 错误 1：PointerUp 触发了放置逻辑
**问题**：Shift+左键按下拿起物品后，松开左键时 PointerUp 又触发了放置
**正确**：Shift/Ctrl 拿起后，PointerUp 不应该做任何事，等待**再次点击**

### 错误 2：slotIndex 绑定问题
**问题**：无论点击哪个格子，都是第一个格子的物品被拿起
**原因**：Bind 方法可能没有被正确调用，或者 slotIndex 没有正确传递

### 错误 3：拖拽状态下无法放置
**问题**：拖拽后物品一直跟随鼠标，无法放置
**原因**：EndDrag 或 OnDrop 事件没有正确处理

### 错误 4：空槽位判定
**问题**：可能没有正确判断 ItemId == -1 为空槽位
**正确**：`slot.IsEmpty` 应该检查 `itemId < 0 || amount <= 0`

---

## 正确的事件流程

### Shift+左键拿起物品的完整流程
```
1. 用户按下 Shift
2. 用户按下左键（PointerDown）
   → 检测到 Shift+左键
   → 执行 ShiftPickup
   → 状态变为 HeldByShift
   → 显示物品跟随鼠标
3. 用户松开左键（PointerUp）
   → 检测到当前是 HeldByShift
   → **不做任何事**（等待再次点击）
4. 用户再次按下左键（PointerDown）
   → 检测到当前是 HeldByShift
   → 根据目标槽位执行放置/堆叠/返回原位
```

### 拖拽物品的完整流程
```
1. 用户按下左键（PointerDown，无修饰键）
   → 记录按下时间和位置
   → 状态保持 Idle
2. 用户移动鼠标（Drag）
   → 检测到长按超过 0.15 秒或移动超过 5 像素
   → BeginDrag 触发
   → 执行 StartDrag
   → 状态变为 Dragging
   → 显示物品跟随鼠标
3. 用户松开左键（EndDrag）
   → 检测到当前是 Dragging
   → 根据目标槽位执行放置/交换/丢弃
   → 状态变为 Idle
```


---

## 修复方案

### 核心修改：事件处理重构

**InventorySlotInteraction.cs** 的职责：
1. 转发 PointerDown 事件给 Manager
2. 转发 BeginDrag/Drag/EndDrag 事件给 Manager
3. **不处理 PointerUp**（除了拖拽结束）

**InventoryInteractionManager.cs** 的职责：
1. 在 `OnSlotPointerDown` 中处理**所有**点击逻辑
2. 根据当前状态决定行为：
   - Idle + Shift → ShiftPickup
   - Idle + Ctrl → CtrlPickup
   - Idle + 无修饰键 → 等待拖拽
   - HeldByShift/HeldByCtrl + 点击 → 放置/堆叠/返回原位
3. 在 `OnSlotEndDrag` 中处理拖拽结束

### 新的事件流程

```
PointerDown 事件：
├── 当前状态 == Idle
│   ├── Shift+Ctrl → 忽略
│   ├── Shift → ShiftPickup → HeldByShift
│   ├── Ctrl → CtrlPickup → HeldByCtrl
│   └── 无修饰键 → 记录时间位置，等待拖拽
│
└── 当前状态 == HeldByShift 或 HeldByCtrl
    ├── 点击空槽位 → 放置 → Idle
    ├── 点击相同物品 → 堆叠 → Idle 或保持
    ├── 点击不同物品 → 返回原位 → Idle
    ├── 点击源槽位 + Shift → 连续二分 → HeldByShift
    └── 点击 PackagePanel 外部 → 丢弃 → Idle

BeginDrag 事件：
├── 当前状态 == HeldByShift 或 HeldByCtrl → 忽略
└── 当前状态 == Idle + 满足拖拽条件 → StartDrag → Dragging

EndDrag 事件：
└── 当前状态 == Dragging
    ├── 松开在空槽位 → 放置 → Idle
    ├── 松开在相同物品 → 堆叠 → Idle
    ├── 松开在不同物品 → 交换 → Idle
    ├── 松开在源槽位 → 返回原位 → Idle
    └── 松开在 PackagePanel 外部 → 丢弃 → Idle

PointerUp 事件：
└── 不做任何事（拖拽由 EndDrag 处理，Held 状态等待再次点击）
```

### slotIndex 绑定问题排查

需要检查：
1. `InventorySlotUI.Awake()` 是否正确调用了 `interaction.Bind(this, false)`
2. `EquipmentSlotUI.Awake()` 是否正确调用了 `interaction.Bind(this, true)`
3. `Bind` 方法是否在正确的时机被调用（Awake 而不是 Start）
4. 每个槽位的 `Index` 属性是否正确设置


---

## 发现的 Bug 根源

### Bug 1：slotIndex 绑定时机错误

**问题代码**（InventorySlotUI.Awake）：
```csharp
void Awake()
{
    // ... 其他初始化 ...
    
    var interaction = gameObject.GetComponent<InventorySlotInteraction>();
    if (interaction == null)
    {
        interaction = gameObject.AddComponent<InventorySlotInteraction>();
    }
    interaction.Bind(this, false);  // ← 此时 index 还是 0！
}

public void Bind(InventoryService inv, ..., int slotIndex, ...)
{
    index = slotIndex;  // ← index 在这里才被设置
}
```

**执行顺序**：
1. `Awake()` 执行 → `interaction.Bind(this, false)` → 此时 `this.Index = 0`
2. 外部调用 `Bind(inv, ..., slotIndex, ...)` → `index = slotIndex`
3. 但 `InventorySlotInteraction` 已经绑定了错误的 index = 0

**结果**：所有 36 个槽位的 `InventorySlotInteraction.slotIndex` 都是 0

### 修复方案

**方案 A**：在 `InventorySlotUI.Bind()` 中重新绑定 Interaction
```csharp
public void Bind(InventoryService inv, ..., int slotIndex, ...)
{
    index = slotIndex;
    // ... 其他代码 ...
    
    // ★ 重新绑定 Interaction
    var interaction = GetComponent<InventorySlotInteraction>();
    if (interaction != null)
    {
        interaction.Bind(this, false);
    }
}
```

**方案 B**：Interaction 不存储 slotIndex，每次从 SlotUI 获取
```csharp
// InventorySlotInteraction
private InventorySlotUI slotUI;
private EquipmentSlotUI equipUI;

public void Bind(InventorySlotUI slot, bool isEquipmentSlot)
{
    slotUI = slot;
    isEquip = isEquipmentSlot;
}

private int GetSlotIndex()
{
    return isEquip ? equipUI.Index : slotUI.Index;
}
```

**推荐方案 B**，因为它更健壮，不依赖调用顺序。
